---
kernelspec:
  name: python3
  display_name: 'Python 3'
---

# 6.2 Zufallszahlen und Simulation

Kein Fertigungsprozess ist absolut präzise. Ein gefertigter Bolzen, der einen
Solldurchmesser von 25.0 mm haben soll, wird in der Realität mal 24.97 mm, mal
25.04 mm oder 24.98 mm messen. Diese unvermeidliche Streuung ist ein zentrales
Thema in der Qualitätssicherung und der Konstruktion. Um solche Prozesse zu
untersuchen, ohne tatsächlich tausende Bauteile fertigen zu müssen, verwenden
Ingenieurinnen und Ingenieure **Simulationen**. In diesem Kapitel lernen wir
mit `numpy.random` ein mächtiges Werkzeug kennen, das Zufallszahlen für genau
solche Simulationen bereitstellt.

## Lernziele

```{admonition} Lernziele
:class: attention
* [ ] Sie können NumPy mit dem Alias `np` importieren.
* [ ] Sie kennen den Unterschied zwischen **Gleichverteilung** und
  **Normalverteilung** und können erklären, welches Modell für
  Fertigungsstreuung realistischer ist.
* [ ] Sie können mit `np.random.uniform()` gleichverteilte Zufallszahlen
  erzeugen.
* [ ] Sie können mit `np.random.normal()` normalverteilte Zufallszahlen erzeugen
  und kennen die Parameter **Mittelwert** und **Standardabweichung**.
* [ ] Sie können Zufallszahlen mit einer for-Schleife kombinieren, um einfache
  Simulationen durchzuführen.
```

## NumPy: ein erster Blick

NumPy (ausgesprochen: "Num-Pie") ist das wichtigste Modul für wissenschaftliches
Rechnen in Python. Es stellt unter anderem effiziente Funktionen für
mathematische Operationen, lineare Algebra und Statistik bereit. In einem
späteren Kapitel werden wir NumPy ausführlich kennenlernen. Für dieses Kapitel
interessiert uns zunächst nur ein Teilbereich: `numpy.random`, also die
Zufallszahlen-Funktionen von NumPy.

NumPy wird mit dem Standard-Alias `np` importiert:

```{code-cell} python
import numpy as np
```

Danach stehen alle NumPy-Funktionen über `np.` zur Verfügung.

## Gleichverteilung und Normalverteilung

Bevor wir Zufallszahlen erzeugen, müssen wir uns fragen: Wie sind die Werte
in der Realität verteilt? Zwei Modelle sind besonders wichtig.

Bei der **Gleichverteilung** ist jeder Wert innerhalb eines Bereichs gleich
wahrscheinlich. Stellen wir uns einen Lichtschalter vor, der zufällig irgendwo
zwischen 0 und 10 einrasten kann: Jede Position ist gleich wahrscheinlich. Wir
würden also genauso oft den Wert 1.3 erwarten wie den Wert 7.8 oder 5.0.

Bei der **Normalverteilung** liegen die meisten Werte nahe einem Mittelwert,
und je weiter ein Wert vom Mittelwert entfernt ist, desto seltener tritt er
auf. Das kennen wir aus dem Alltag: Die meisten Menschen haben eine
Körpergröße nahe dem Durchschnitt, sehr kleine oder sehr große Menschen sind
selten. Auch die Noten in einer großen Prüfung sind oft normalverteilt: Viele
Studierende erreichen mittlere Noten, sehr wenige erzielen Höchst- oder
Tiefstnoten.

Für einen Fertigungsprozess gilt: Die Maschine versucht, den Solldurchmesser
zu treffen. Kleine Abweichungen passieren ständig, große Abweichungen sind
selten. Das entspricht einer Normalverteilung. Eine Gleichverteilung würde
bedeuten, dass ein Bolzen von 24.51 mm genauso häufig vorkommt wie einer von
25.0 mm, was physikalisch nicht realistisch ist.

## Gleichverteilte Zufallszahlen: np.random.uniform()

Die Funktion `np.random.uniform(low, high)` erzeugt eine gleichverteilte
Zufallszahl zwischen `low` und `high`:

```{code-cell} python
import numpy as np

durchmesser = np.random.uniform(24.5, 25.5)
print(f"Simulierter Durchmesser: {durchmesser:.3f} mm")
```

Jedes Mal, wenn wir diese Zelle ausführen, erhalten wir einen anderen Wert,
der gleichmäßig zwischen 24.5 mm und 25.5 mm verteilt ist.

```{admonition} Mini-Übung
:class: tip
Führen Sie die obige Code-Zelle zehnmal hintereinander aus. Notieren Sie die
Werte. Beobachten Sie: Treten Werte nahe 25.0 mm häufiger auf als Werte nahe
den Grenzen 24.5 mm und 25.5 mm?
```

```{code-cell} python
# Code-Zelle
```

````{admonition} Lösung
:class: tip
:class: dropdown
Bei der Gleichverteilung treten alle Werte gleich häufig auf. Werte nahe 25.0 mm
sind also nicht häufiger als Werte nahe den Grenzen. Das ist der Kernunterschied
zur Normalverteilung, die wir im nächsten Abschnitt kennenlernen.
````

## Normalverteilte Zufallszahlen: np.random.normal()

Die Funktion `np.random.normal(loc, scale)` erzeugt eine normalverteilte
Zufallszahl. Der Parameter `loc` gibt den **Mittelwert** an, also den Wert, um
den die Zufallszahlen zentriert sind. Der Parameter `scale` gibt die
**Standardabweichung** an, also ein Maß dafür, wie breit die Streuung ist. Eine
kleine Standardabweichung bedeutet einen präzisen Prozess, eine große bedeutet
viel Streuung.

```{code-cell} python
import numpy as np

# Bolzendurchmesser: Mittelwert 25.0 mm, Standardabweichung 0.15 mm
durchmesser = np.random.normal(loc=25.0, scale=0.15)
print(f"Simulierter Durchmesser: {durchmesser:.3f} mm")
```

```{admonition} Mini-Übung
:class: tip
Führen Sie die obige Code-Zelle zehnmal hintereinander aus. Vergleichen Sie die
Werte mit denen aus der Mini-Übung zu `np.random.uniform()`. Was beobachten Sie?
```

```{code-cell} python
# Code-Zelle
```

````{admonition} Lösung
:class: tip
:class: dropdown
Bei der Normalverteilung treten Werte nahe dem Mittelwert 25.0 mm deutlich
häufiger auf als Werte weit davon entfernt. Extreme Werte wie 24.5 mm oder
25.5 mm sind sehr selten. Das ist das charakteristische Verhalten der
Normalverteilung und entspricht dem realistischen Verhalten eines
Fertigungsprozesses.
````

## Fertigungsprozess simulieren

Jetzt kombinieren wir `np.random.normal()` mit einer for-Schleife und der
Qualitätsprüfung aus Kapitel 5.8. Wir simulieren die Fertigung von 500 Bolzen
und prüfen für jeden, ob er innerhalb der Toleranz von 25.0 mm ± 0.3 mm liegt:

```{code-cell} python
import numpy as np
import plotly.express as px

# Toleranzgrenzen aus Sollwert und Toleranz berechnen
SOLL_MM = 25.0
TOLERANZ_MM = 0.3
GRENZE_UNTEN_MM = SOLL_MM - TOLERANZ_MM   # 24.7 mm
GRENZE_OBEN_MM = SOLL_MM + TOLERANZ_MM    # 25.3 mm
ANZAHL_BOLZEN = 500

anzahl_iO = 0
anzahl_niO = 0

for i in range(ANZAHL_BOLZEN):
    # Durchmesser eines Bolzens simulieren: normalverteilt um den Sollwert
    d = np.random.normal(loc=SOLL_MM, scale=0.15)

    # Prüfen, ob der Bolzen innerhalb der Toleranz liegt
    ist_fehlerhaft = False
    if d < GRENZE_UNTEN_MM:
        ist_fehlerhaft = True   # Untermaß
    if d > GRENZE_OBEN_MM:
        ist_fehlerhaft = True   # Übermaß

    # Zähler je nach Ergebnis erhöhen
    if ist_fehlerhaft == True:
        anzahl_niO = anzahl_niO + 1
    if ist_fehlerhaft == False:
        anzahl_iO = anzahl_iO + 1

# Ausschussquote in Prozent berechnen
ausschussquote = anzahl_niO / ANZAHL_BOLZEN * 100

print(f"iO-Teile:       {anzahl_iO}")
print(f"niO-Teile:      {anzahl_niO}")
print(f"Ausschussquote: {ausschussquote:.1f} %")

fig = px.bar(x=["iO-Teile", "niO-Teile"],
             y=[anzahl_iO, anzahl_niO],
             labels={"x": "Klassifizierung", "y": "Anzahl Bolzen"},
             title=f"Qualitätsprüfung: Simulation von {ANZAHL_BOLZEN} Bolzen")
fig.show()
```

Bei einer Standardabweichung von 0.15 mm und einer Toleranz von ±0.3 mm liegen
die Toleranzgrenzen bei ±2σ (zwei Standardabweichungen vom Mittelwert). Die
Ausschussquote sollte daher bei ca. 4.6 % liegen. Da wir mit Zufallszahlen
arbeiten, ergibt jede Ausführung ein leicht anderes Ergebnis.

```{admonition} Mini-Übung
:class: tip
Verändern Sie die Standardabweichung auf 0.05 mm (sehr präziser Prozess) und
dann auf 0.3 mm (wenig präziser Prozess). Beobachten Sie, wie sich die
Ausschussquote verändert. Welche Standardabweichung ist notwendig, damit die
Ausschussquote unter 1 % bleibt?
```

```{code-cell} python
# Code-Zelle
```

````{admonition} Lösung
:class: tip
:class: dropdown
Bei `scale=0.05` (Toleranz entspricht 6σ) ist die Ausschussquote nahezu 0 %.
Bei `scale=0.15` (Toleranz entspricht 2σ) liegt die Ausschussquote bei ca. 4.6 %.
Bei `scale=0.3` (Toleranz entspricht 1σ) liegt die Ausschussquote bei ca. 31.7 %.

Eine Ausschussquote unter 1 % wird bei einer Standardabweichung von ca. 0.12 mm
oder kleiner erreicht (Toleranz entspricht dann ca. ±2.5σ). In der
Qualitätssicherung beschreibt der **Fähigkeitsindex** $C_p$ das Verhältnis
zwischen Toleranz und Standardabweichung. Das werden wir in einem späteren
Kapitel genauer untersuchen.
````

## Zusammenfassung und Ausblick

In diesem Kapitel haben wir NumPy zum ersten Mal kennengelernt und mit
`numpy.random` erste Simulationen durchgeführt. Wir haben den Unterschied
zwischen Gleichverteilung und Normalverteilung kennengelernt und gesehen, warum
die Normalverteilung für Fertigungsprozesse das realistischere Modell ist. Mit
`np.random.normal()` haben wir die Qualitätsprüfung aus Kapitel 5.8 zu einer
Simulation erweitert und beobachtet, wie die Standardabweichung die
Ausschussquote beeinflusst. In einem späteren Kapitel werden wir NumPy
vollständig einführen, Histogramme zur Visualisierung von Verteilungen
kennenlernen und die Simulation um weitere statistische Kenngrößen ergänzen.
