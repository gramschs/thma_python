---
kernelspec:
  name: python3
  display_name: 'Python 3'
---

# 6.1 Indizierung, Strings und f-Strings

In Kapitel 3 haben wir Listen kennengelernt und gelernt, wie man mit einem
positiven Index auf einzelne Elemente zugreift. In der Praxis braucht man aber
häufig das letzte Element einer Sammlung, ohne deren genaue Länge zu kennen.
Angenommen, wir erfassen laufend Temperaturmessungen an einer Bremsscheibe und
möchten jederzeit den aktuellsten Wert abrufen. Python bietet dafür den
negativen Index, den wir in diesem Kapitel kennenlernen. Danach vertiefen wir
den Umgang mit Strings und lernen mit den sogenannten f-Strings eine elegante
Methode kennen, Ausgaben sauber zu formatieren.

## Lernziele

```{admonition} Lernziele
:class: attention
* [ ] Sie können mit einem **negativen Index** auf das letzte und vorletzte
  Element einer Liste zugreifen.
* [ ] Sie können Strings wie Listen **indizieren** und kennen den wichtigsten
  Unterschied: Strings sind **unveränderlich**.
* [ ] Sie können mit **f-Strings** Ausgaben formatieren und Zahlen auf eine
  bestimmte Anzahl von Nachkommastellen runden.
```

## Negativer Index

Betrachten wir eine Liste mit Messwerten der Bremsscheibentemperatur, die
während eines Bremsvorgangs aufgezeichnet wurden:

```{code-cell} python
temperaturen = [80, 145, 210, 265, 305, 335, 350]
```

Mit einem positiven Index greifen wir von vorne auf die Liste zu: `temperaturen[0]`
liefert den ersten Wert, `temperaturen[1]` den zweiten und so weiter. Der letzte
Wert befindet sich an Index `len(temperaturen) - 1`, also an Index 6. Das ist
umständlich, vor allem wenn sich die Länge der Liste im Laufe des Programms
ändert.

Python bietet dafür eine elegante Lösung: den **negativen Index**. Der Index
`-1` bezeichnet immer das letzte Element, `-2` das vorletzte und so weiter.

```{code-cell} python
temperaturen = [80, 145, 210, 265, 305, 335, 350]

print(temperaturen[-1])   # letztes Element:      350
print(temperaturen[-2])   # vorletztes Element:   335
print(temperaturen[-7])   # erstes Element:        80
```

Der negative Index und der positive Index sind zwei Sichtweisen auf dieselbe
Liste. Die folgende Tabelle zeigt die Entsprechungen für unsere Temperaturliste:

| Position | positiver Index | negativer Index | Wert |
| -------- | --------------- | --------------- | ---- |
| 1. Element | 0 | -7 | 80 |
| 2. Element | 1 | -6 | 145 |
| 3. Element | 2 | -5 | 210 |
| 4. Element | 3 | -4 | 265 |
| 5. Element | 4 | -3 | 305 |
| 6. Element | 5 | -2 | 335 |
| 7. Element | 6 | -1 | 350 |

In der Praxis verwendet man fast ausschließlich `-1` und gelegentlich `-2`. Die
weiteren negativen Indizes sind selten sinnvoll, da man dann besser mit einem
positiven Index arbeitet.

````{admonition} Mini-Übung
:class: tip
Gegeben ist folgende Liste mit Bauteilbezeichnungen:

```python
bauteile = ["Welle", "Lager", "Dichtung", "Schraube", "Mutter"]
```

1. Geben Sie das erste Bauteil mit positivem und das letzte Bauteil mit negativem Index
   aus.
2. Geben Sie das vorletzte Bauteil aus.
3. Welches Ergebnis liefert `bauteile[-3]`? Überlegen Sie zuerst, bevor Sie den
   Code ausführen.
````

```{code-cell} python
# Code-Zelle
```

````{admonition} Lösung
:class: tip
:class: dropdown
```python
bauteile = ["Welle", "Lager", "Dichtung", "Schraube", "Mutter"]

# 1. Erstes und letztes Bauteil
print(bauteile[0])    # Welle
print(bauteile[-1])   # Mutter

# 2. Vorletztes Bauteil
print(bauteile[-2])   # Schraube

# 3. Drittes Element von hinten
print(bauteile[-3])   # Dichtung
```

`bauteile[-3]` liefert `"Dichtung"`, da von hinten gezählt das dritte Element
an Index 2 von vorne liegt (bei einer Liste mit 5 Elementen gilt: -3 = 5 - 3 = 2).
````

## Strings indizieren

Strings verhalten sich beim Indizieren ähnlich wie Listen. Auch ein String hat
einen Index, jedes Zeichen hat seine eigene Position innerhalb des Strings. Der
String `"Welle"` hat fünf Zeichen, die an den Positionen 0 bis 4 (bzw. -1 bis
-5) gespeichert sind.

```{code-cell} python
bauteil = "Welle"

print(bauteil[0])    # erstes Zeichen:  W
print(bauteil[-1])   # letztes Zeichen: e
print(len(bauteil))  # Länge:           5
```

Die Funktion `len()`, die wir aus Kapitel für Listen kennen, funktioniert also
auch für Strings und liefert die Anzahl der Zeichen.

Hier endet jedoch die Ähnlichkeit mit Listen. Der wichtigste Unterschied ist,
dass Strings **unveränderlich** sind. Das bedeutet: Einzelne Zeichen eines
Strings können nachträglich nicht ausgetauscht werden. Der folgende Versuch führt
daher zu einem Fehler:

```{code-cell} python
:tags: [raises-exception]
bauteil = "Welle"
bauteil[0] = "K"   # TypeError: 'str' object does not support item assignment
```

Bei einer Liste ist derselbe Schreibzugriff problemlos möglich:

```{code-cell} python
bauteile = ["Welle", "Lager", "Dichtung"]
bauteile[0] = "Kurbelwelle"
print(bauteile)
```

Möchte man einen String verändern, muss man stattdessen einen neuen String
erzeugen. Das kann zum Beispiel durch String-Verkettung mit `+` geschehen, wie
wir es in Kapitel 2 gelernt haben.

````{admonition} Mini-Übung
:class: tip
Gegeben ist die Bauteilbezeichnung `"Antriebswelle_v1"`.

1. Geben Sie das erste und das letzte Zeichen des Strings aus.
2. Bestimmen Sie die Länge des Strings.
3. Prüfen Sie mit einer if-Bedingung, ob das letzte Zeichen `"1"` ist, und
   geben Sie in diesem Fall `"Bauteil hat Version 1."` aus.
4. Erzeugen Sie den String `"Antriebswelle_v1_FINAL"` durch Verkettung und 
   geben Sie ihn aus.
````

```{code-cell} python
# Code-Zelle
```

````{admonition} Lösung
:class: tip
:class: dropdown
```python
bauteil = "Antriebswelle_v1"

# 1. Erstes und letztes Zeichen
print(bauteil[0])    # A
print(bauteil[-1])   # 1

# 2. Länge
print(len(bauteil))  # 16

# 3. Letzte Zeichen prüfen
if bauteil[-1] == "1":
    print("Bauteil hat Version 1.")

# 4. String verketten
bauteil_final = bauteil + "_FINAL"
print(bauteil_final)   # Antriebswelle_v1_FINAL
```
````

## f-Strings

In Kapitel 5 haben wir mehrfach festgestellt, dass Ausgaben mit vielen
Nachkommastellen unpraktisch sind. Bisher haben wir Variablen mit `str()` in
Strings umgewandelt und mit `+` verkettet:

```{code-cell} python
bremsweg = 24.336734693877552
print("Bremsweg: " + str(bremsweg) + " m")
```

Das ist lesbar, aber umständlich. Mit **f-Strings** geht das deutlich eleganter.
Ein f-String beginnt mit dem Buchstaben `f` vor den Anführungszeichen. Innerhalb
des Strings können Variablen direkt in geschweiften Klammern `{ }` eingebettet
werden:

```{code-cell} python
bremsweg = 24.336734693877552
print(f"Bremsweg: {bremsweg} m")
```

Das Ergebnis ist identisch, aber der Code ist kürzer und besser lesbar. Das `f`
steht für das englische Wort "formatted".

Der eigentliche Mehrwert von f-Strings liegt in der Möglichkeit, Zahlen direkt
zu formatieren. Innerhalb der geschweiften Klammern kann nach einem Doppelpunkt
ein **Formatierungsausdruck** angegeben werden:

```{code-cell} python
bremsweg = 24.336734693877552

print(f"Bremsweg: {bremsweg:.1f} m")   # 1 Nachkommastelle
print(f"Bremsweg: {bremsweg:.2f} m")   # 2 Nachkommastellen
print(f"Bremsweg: {bremsweg:.0f} m")   # 0 Nachkommastellen (Ganzzahl)
```

Der Formatierungsausdruck `:.2f` bedeutet: Fließkommazahl (`f`) mit 2
Nachkommastellen (`.2`). Die Zahl wird dabei automatisch gerundet.

Ganzzahlen können ebenfalls formatiert werden, zum Beispiel mit einer
Mindestbreite für die Ausgabe:

```{code-cell} python
for v in range(30, 131, 10):
    bremsweg = v**2 / 100
    print(f"v = {v:3d} km/h,  Bremsweg = {bremsweg:6.2f} m")
```

Hier bedeutet `{v:3d}`, dass die Ganzzahl (`d` für "digit") in einem Feld der
Breite 3 ausgegeben wird. `{bremsweg:6.2f}` reserviert ein Feld der Breite 6
mit 2 Nachkommastellen. Das sorgt dafür, dass die Werte spaltenweise
untereinander ausgerichtet werden, was die Tabelle deutlich übersichtlicher
macht.

```{admonition} Mini-Übung
:class: tip
In Kapitel 5.3 haben wir die Fliehkraft für verschiedene Drehzahlen berechnet.
Die Ausgabe enthielt viele Nachkommastellen. Verwenden Sie einen f-String, um
die Ausgabe auf 1 Nachkommastelle zu runden.

```python
PI = 3.14159
m_kg = 2.0
r_m = 0.3

for n in range(500, 3001, 500):
    omega = 2 * PI * n / 60
    F_N = m_kg * omega**2 * r_m
    print("n = " + str(n) + " U/min,  F = " + str(F_N) + " N")
```
```

```{code-cell} python
# Code-Zelle
```

````{admonition} Lösung
:class: tip
:class: dropdown
```python
PI = 3.14159
m_kg = 2.0
r_m = 0.3

for n in range(500, 3001, 500):
    omega = 2 * PI * n / 60
    F_N = m_kg * omega**2 * r_m
    print(f"n = {n:4d} U/min,  F = {F_N:8.1f} N")
```

Ausgabe:
```
n =  500 U/min,  F =   1644.9 N
n = 1000 U/min,  F =   6579.7 N
n = 1500 U/min,  F =  14804.3 N
n = 2000 U/min,  F =  26319.7 N
n = 2500 U/min,  F =  41124.5 N
n = 3000 U/min,  F =  59219.3 N
```

Die Ausgabe ist durch die Feldbreiten jetzt spaltenweise ausgerichtet und
dadurch deutlich übersichtlicher als die ursprüngliche Version mit
String-Verkettung.
````

```{dropdown} Video "f-Strings in Python" von Programmieren Starten
<iframe width="560" height="315" src="https://www.youtube.com/embed/BxkDvRMS_X0"
title="YouTube video player" frameborder="0" allow="accelerometer; autoplay;
clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
allowfullscreen></iframe>
```

## Zusammenfassung und Ausblick

In diesem Kapitel haben wir den negativen Index kennengelernt, mit dem wir
bequem auf das letzte Element einer Liste oder eines Strings zugreifen können,
ohne die genaue Länge zu kennen. Wir haben gesehen, dass Strings beim Indizieren
wie Listen funktionieren, aber im Gegensatz zu Listen unveränderlich sind. Mit
f-Strings haben wir schließlich ein mächtiges Werkzeug kennengelernt, das
formatierte Ausgaben deutlich kompakter und lesbarer macht als die bisherige
String-Verkettung. Im nächsten Kapitel lernen wir das `random`-Modul kennen und
simulieren damit Zufallsprozesse aus dem Ingenieuralltag.
