{"version":"1","records":[{"hierarchy":{"lvl1":"1.1 Algorithmus und Programmiersprachen"},"type":"lvl1","url":"/chapter01-sec01","position":0},{"hierarchy":{"lvl1":"1.1 Algorithmus und Programmiersprachen"},"content":"Es gibt viele Gründe, warum es sich lohnt, Programmieren zu lernen. Die\nNachfrage nach Ingenieurinnen und Ingenieuren, die zusätzlich Programmieren\nkönnen, wächst aufgrund der Digitalisierung der Industrie rasant. Programmieren\nfördert kritisches Denken und Problemlösungsfähigkeiten. Umgekehrt werden durch\nProgrammieren diese Fähigkeiten weiter entwickelt. Zudem fördert Programmieren\ndas Verständnis von Technologie und Computersystemen. Es kann helfen, die\nFunktionsweise von Software und Hardware besser zu verstehen und Einblicke in\ndie Arbeitsweise von Websites, Anwendungen und anderen Technologien zu gewinnen.\nProgrammierung kann auch dabei helfen, Routineaufgaben zu automatisieren und\nZeit zu sparen. Dies kann Fehler minimieren und die Effizienz steigern.","type":"content","url":"/chapter01-sec01","position":1},{"hierarchy":{"lvl1":"1.1 Algorithmus und Programmiersprachen","lvl2":"Lernziele"},"type":"lvl2","url":"/chapter01-sec01#lernziele","position":2},{"hierarchy":{"lvl1":"1.1 Algorithmus und Programmiersprachen","lvl2":"Lernziele"},"content":"Lernziele\n\nSie können erklären, was ein Algorithmus ist.\n\nSie wissen, was eine Programmiersprache ist.\n\nSie kennen den Unterschied zwischen höheren Programmiersprachen und\nMaschinensprache.\n\nSie wissen, was der Unterschied zwischen einer kompilierten\nProgrammiersprache und einer interpretierten Programmiersprache ist. Sie\nkönnen für beide Kategorien Beispiele benennen.","type":"content","url":"/chapter01-sec01#lernziele","position":3},{"hierarchy":{"lvl1":"1.1 Algorithmus und Programmiersprachen","lvl2":"Algorithmus"},"type":"lvl2","url":"/chapter01-sec01#algorithmus","position":4},{"hierarchy":{"lvl1":"1.1 Algorithmus und Programmiersprachen","lvl2":"Algorithmus"},"content":"Programmieren bedeutet, dem Computer eine Reihe von Anweisungen zu geben. Es\ngeht darum, mit Hilfe einer Abfolge von Anweisungen ein Problem zu lösen. Ein\nwichtiger Aspekt des Programmierens ist die Fähigkeit, komplexe Probleme in\nkleinere, leichter zu lösende Aufgaben zu unterteilen. Diese Aufgaben können\ndann einzeln gelöst und in einem größeren Programm kombiniert werden, um das\nProblem als Ganzes zu lösen.\n\nDiese schrittweise Beschreibung der Lösung eines Problems nennt man\nAlgorithmus. Ein Algorithmus ist ein klar definierter Satz von Anweisungen\noder Regeln, die von einem Computer (oder auch von einem Menschen) ausgeführt\nwerden können, um ein bestimmtes Ergebnis zu erzielen.\n\nEin Beispiel aus dem Alltag ist die Steuerung eines Fahrstuhls:\n\nJemand drückt im Erdgeschoss den Knopf.\n\nDer Fahrstuhl fährt nach unten, hält an, und die Tür öffnet sich.\n\nDie Person steigt ein und wählt die 3. Etage.\n\nDer Fahrstuhl schließt die Tür, fährt hoch bis zur 3. Etage, hält wieder an,\nöffnet die Tür und die Person steigt aus.\n\nMini-Übung\n\nNehmen Sie sich 5 Minuten Zeit und schreiben Sie die Schritte auf, die ein\nFahrstuhl befolgen muss, um eine Person vom Erdgeschoss in die 2. Etage zu\nbringen.\n\nLösung\n\nWarte auf Knopfdruck im Erdgeschoss.\n\nFahre ins Erdgeschoss (falls nicht schon dort).\n\nÖffne Tür.\n\nWarte, bis Person eingestiegen ist.\n\nSchließe Tür.\n\nFahre in die 2. Etage.\n\nÖffne Tür.\n\nWarte, bis Person ausgestiegen ist.\n\nSchließe Tür.\n\nDie obige Lösung funktioniert nur für den Transport vom Erdgeschoss in die 2.\nEtage. Ein echter Fahrstuhl-Algorithmus muss aber allgemeiner sein und für\nbeliebige Start- und Zieletagen funktionieren. Das folgende Flussdiagramm zeigt\neinen solchen allgemeinen Algorithmus:flowchart TD\n    A[Start: Fahrstuhl wartet] --> B{Knopf außen gedrückt?}\n    B -->|Nein| B\n    B -->|Ja| C[Fahre zu der Etage mit dem Knopf]\n    C --> D[Öffne Tür]\n    D --> E{Person eingestiegen?}\n    E -->|Nein| E\n    E -->|Ja| F[Schließe Tür]\n    F --> G{Ziel-Knopf innen gedrückt?}\n    G -->|Nein| G\n    G -->|Ja| H[Fahre zur Ziel-Etage]\n    H --> I[Öffne Tür]\n    I --> J{Person ausgestiegen?}\n    J -->|Nein| J\n    J -->|Ja| K[Schließe Tür]\n    K --> A\n    \n    style A fill:#e1f5fe\n    style B fill:#fff3e0\n    style E fill:#fff3e0\n    style G fill:#fff3e0\n    style J fill:#fff3e0\n\nIn dem Flussdiagramm stehen die Rauten für Entscheidungen und die Rechtecke für\nAktionen. Der Pfeil zurück zum Start zeigt: Ein Fahrstuhl arbeitet in einer\nEndlosschleife und wartet kontinuierlich auf neue Anfragen.\n\nDie Beschreibung kann unterschiedlich detailliert sein. Zum Beispiel kann man\npräzisieren, wie lange die Tür geöffnet bleiben soll oder was passiert, wenn\ngleichzeitig andere Knöpfe gedrückt werden. Hier erkennt man: Ein Algorithmus\nkann sehr einfach beginnen, aber durch zusätzliche Fälle immer komplexer werden.\n\nMini-Übung\n\nÜberlegen Sie, welche zusätzlichen Regeln notwendig wären, wenn der Fahrstuhl\ngleichzeitig mehrere Anfragen erhält (z. B. jemand möchte in die 4. Etage und\njemand anders in die 2. Etage).\n\nLösung\n\nDer Fahrstuhl muss entscheiden, in welcher Reihenfolge die Stockwerke\nangefahren werden.\n\nMögliches Vorgehen: Immer in der aktuellen Fahrtrichtung alle Stockwerke\nbedienen, bevor gewendet wird.\n\nBeispiel: Wenn der Fahrstuhl im Erdgeschoss startet und Knöpfe für die 2. und\n4. Etage gedrückt sind, fährt er zuerst zur 2., dann zur 4. Etage.\n\nAuf die Idee, Alltagsprozesse in Form eines Algorithmus zu beschreiben, werden\nwir in späteren Kapiteln zurückkehren. Als nächstes beschäftigen wir uns damit,\nwie dem Computer solche Anweisungen in einer Programmiersprache erteilt werden.","type":"content","url":"/chapter01-sec01#algorithmus","position":5},{"hierarchy":{"lvl1":"1.1 Algorithmus und Programmiersprachen","lvl2":"Programmiersprachen"},"type":"lvl2","url":"/chapter01-sec01#programmiersprachen","position":6},{"hierarchy":{"lvl1":"1.1 Algorithmus und Programmiersprachen","lvl2":"Programmiersprachen"},"content":"Eine Programmiersprache ist eine formale Sprache, mit der sich\nDatenstrukturen und Algorithmen beschreiben lassen, sodass ein Computer diese\nAnweisungen ausführen kann.\n\nEs gibt nicht die eine wichtigste oder beste Programmiersprache. Welche\nSprache man verwendet, hängt immer von der Anwendung ab. Für ein\nSmartphone-Spiel wird eine andere Sprache gewählt als für die numerische\nSimulation in den Ingenieurwissenschaften. Einen Überblick über die Beliebtheit\nvon Programmiersprachen bietet der sogenannte Tiobe-Index:\n\nhttps://​www​.tiobe​.com​/tiobe​-index/\n\nMini-Übung\n\nRecherchieren Sie im Tiobe-Index nach den Programmiersprachen MATLAB und Python.\n\nAuf welchem Platz stehen die beiden Programmiersprachen aktuell?\n\nSchauen Sie sich auch die langfristige Entwicklung an. Wie haben sich beide\nSprachen in den letzten 10 Jahren entwickelt?\n\nLösung\n\nPython steht typischerweise in den Top 3, MATLAB meist zwischen Platz 15-20.\n\nPython zeigt seit Jahren einen deutlichen Aufwärtstrend, während MATLAB\nstagniert oder leicht rückläufig ist.\n\nBesonders für Ingenieurstudierende stellt sich oft die Frage: MATLAB oder\nPython? Während MATLAB traditionell in vielen technischen Fächern gelehrt wird,\nzeigt die Entwicklung der letzten Jahre einen klaren Trend zu Python. Dies liegt\nnicht nur an der größeren Vielseitigkeit, sondern auch daran, dass\nPython-Kenntnisse weit über die Ingenieurwissenschaften hinaus wertvoll sind.\n\nIn der Anfangszeit der Computer waren Programmiersprachen noch sehr nah an der\nMaschinensprache. Maschinensprache besteht aus Binärcode (Nullen und\nEinsen), den der Prozessor direkt ausführt. Hier ein Beispiel in Assembler,\neiner sehr maschinenorientierten Sprache, die bereits schwer lesbar ist:\n\n\n\nFigure 1:“Hallo Welt” in Assembler\n(Quelle: \n\nWikipedia → Assemblersprache)\n\nIn einer modernen Sprache wie Python ist der gleiche Code deutlich kürzer\nund leichter verständlich:\n\nprint('Hallo Welt')\n\n\n\nHeute arbeiten wir fast ausschließlich mit den sogenannten höheren\nProgrammiersprachen (wie Python, MATLAB oder C++), die für Menschen leichter\nverständlich sind. Damit Computer diese Anweisungen ausführen können, müssen sie\naber trotzdem in Maschinensprache übersetzt werden. Das geschieht auf zwei\nArten:\n\nCompiler-Sprachen: Der gesamte Code wird vorab in Maschinensprache\nübersetzt. Der Übersetzungsvorgang heißt Kompilieren.\n\nInterpreter-Sprachen: Der Code wird erst beim Ausführen Zeile für Zeile in\nMaschinensprache übersetzt. Der zeilenweise Ausführung wird Interpretieren\ngenannt.\n\nManchmal wird kompilierter Code als Programm und interpretierter Code als Skript\nbezeichnet. Im Alltag ist diese Unterscheidung aber nicht immer wichtig; oft\nsagt man zu beidem schlicht »Programm«.\n\nMini-Übung\n\nOrdnen Sie die folgenden Programmiersprachen zu: Sind sie kompiliert oder\ninterpretiert?\n\nC bzw. C++\n\nC# (ausgesprochen: C Sharp)\n\nJavaScript\n\nPython\n\nVisual Basic\n\nLösung\n\nC bzw. C++ → kompiliert\n\nC# → kompiliert\n\nJavaScript → interpretiert\n\nPython → interpretiert\n\nVisual Basic → kompiliert\n\nInsgesamt ist der Unterschied zwischen kompilierten und interpretierten Sprachen\nvor allem eine Frage der Geschwindigkeit und Flexibilität. Kompilierte Programme\nsind in der Regel schneller als interpretierte Programme, da der Maschinencode\ndirekt vom Betriebssystem ausgeführt werden kann. Umgekehrt können Änderungen\ndes Programms bei interpretierten Programmen schneller durchgeführt werden, da\ndiese ja ohnehin Zeile für Zeile abgearbeitet und interpretiert werden. Dies\nbedeutet, dass Änderungen am Code sofort wirksam werden, ohne dass eine erneute\nKompilierung erforderlich ist.\n\nLetztendlich hängt die Wahl der Programmiersprache von den Anforderungen des\nProjekts ab und davon, welche Kompromisse zwischen Geschwindigkeit und\nFlexibilität akzeptabel sind.","type":"content","url":"/chapter01-sec01#programmiersprachen","position":7},{"hierarchy":{"lvl1":"1.1 Algorithmus und Programmiersprachen","lvl2":"Warum Python?"},"type":"lvl2","url":"/chapter01-sec01#warum-python","position":8},{"hierarchy":{"lvl1":"1.1 Algorithmus und Programmiersprachen","lvl2":"Warum Python?"},"content":"Was ist überhaupt Python? Wikipedia beschreibt Python so:\n\n“Python ([ˈpʰaɪθn̩], [ˈpʰaɪθɑn], auf Deutsch auch [ˈpʰyːtɔn]) ist eine\nuniverselle, üblicherweise interpretierte, höhere Programmiersprache. Sie hat\nden Anspruch, einen gut lesbaren, knappen Programmierstil zu fördern. So\nwerden beispielsweise Blöcke nicht durch geschweifte Klammern, sondern durch\nEinrückungen strukturiert.”\n(Quelle: \n\nWikipedia)\n\nIn dieser Vorlesung verwenden wir Python als Programmiersprache, da Python viele\nVorteile für den Einstieg bietet:\n\nEinfache Syntax: Python hat eine klare und leicht verständliche Syntax, die\nes leicht macht, die Grundlagen der Programmierung zu erlernen. Die Syntax\nist lesbar und ähnelt der englischen Sprache, was das Verständnis\nerleichtert.\n\nVielseitigkeit: Python ist eine sehr vielseitige Programmiersprache, die in\nvielen verschiedenen Bereichen eingesetzt werden kann. Sie wird oft für\nDatenanalyse, künstliche Intelligenz, Webentwicklung und wissenschaftliches\nRechnen verwendet.\n\nGroße Community: Python hat eine große Community von Entwicklern, die aktiv\nan der Weiterentwicklung der Sprache und an der Bereitstellung von\nHilfestellung und Ressourcen für Anfänger beteiligt sind. Es gibt viele\nOnline-Foren, Kurse und Tutorials, die das Erlernen der Sprache erleichtern.\n\nInteraktiver Modus: Python bietet einen interaktiven Modus, der es\nAnfängern ermöglicht, Code Zeile für Zeile auszuführen und das Ergebnis\nsofort zu sehen. Dies macht das Experimentieren und die Suche nach Fehlern im\nCode sehr einfach und effektiv.\n\nPlattformunabhängigkeit: Python kann auf verschiedenen Betriebssystemen wie\nWindows, Mac und Linux ausgeführt werden.\n\nDas Erlernen einer Programmiersprache ist ein bisschen wie das Lernen einer\nFremdsprache: Die erste ist die schwierigste. Danach fällt der Umstieg auf\nandere Sprachen wesentlich leichter.","type":"content","url":"/chapter01-sec01#warum-python","position":9},{"hierarchy":{"lvl1":"1.1 Algorithmus und Programmiersprachen","lvl2":"Zusammenfassung und Ausblick"},"type":"lvl2","url":"/chapter01-sec01#zusammenfassung-und-ausblick","position":10},{"hierarchy":{"lvl1":"1.1 Algorithmus und Programmiersprachen","lvl2":"Zusammenfassung und Ausblick"},"content":"In diesem Kapitel haben wir die Vorteile des Programmierens für Ingenieure\ndiskutiert, den Begriff des Algorithmus anhand der Fahrstuhlsteuerung eingeführt\nund die Unterschiede zwischen verschiedenen Programmiersprachen erklärt.\nAußerdem haben wir gesehen, warum Python als erste Sprache besonders geeignet\nist. Im nächsten Kapitel beschäftigen wir uns mit den technischen\nVoraussetzungen, um eigene Python-Programme zu schreiben, und benutzen Python\nals Taschenrechner.","type":"content","url":"/chapter01-sec01#zusammenfassung-und-ausblick","position":11},{"hierarchy":{"lvl1":"1.2 Jupyter Notebooks und Python als Taschenrechner"},"type":"lvl1","url":"/chapter01-sec02","position":0},{"hierarchy":{"lvl1":"1.2 Jupyter Notebooks und Python als Taschenrechner"},"content":"In dieser Vorlesung werden wir das Python-Programmieren mit Hilfe von Jupyter\nNotebooks lernen. Daher klären wir zunächst, was Jupyter Notebooks sind, und\nverwenden anschließend Python als Taschenrechner. Ergebnisse von einfachen\nRechnungen lassen wir uns mit der print()-Funktion anzeigen.","type":"content","url":"/chapter01-sec02","position":1},{"hierarchy":{"lvl1":"1.2 Jupyter Notebooks und Python als Taschenrechner","lvl2":"Lernziele"},"type":"lvl2","url":"/chapter01-sec02#lernziele","position":2},{"hierarchy":{"lvl1":"1.2 Jupyter Notebooks und Python als Taschenrechner","lvl2":"Lernziele"},"content":"Lernziele\n\nSie wissen, was ein Jupyter Notebook ist.\n\nSie können Python als Taschenrechner benutzen.\n\nSie können Ergebnisse von Rechnungen mit print() anzeigen.\n\nSie wissen, was ein Argument einer Anweisung ist.","type":"content","url":"/chapter01-sec02#lernziele","position":3},{"hierarchy":{"lvl1":"1.2 Jupyter Notebooks und Python als Taschenrechner","lvl2":"Was sind Jupyter Notebooks?"},"type":"lvl2","url":"/chapter01-sec02#was-sind-jupyter-notebooks","position":4},{"hierarchy":{"lvl1":"1.2 Jupyter Notebooks und Python als Taschenrechner","lvl2":"Was sind Jupyter Notebooks?"},"content":"Jupyter Notebooks führen Text, Python-Code, Bilder und Videos in einem einzigen\ninteraktiven digitalen Notizbuch zusammen. Sie gehören zu den bekanntesten\nAnwendungen in der Programmierung und werden häufig für Datenanalyse,\nmaschinelles Lernen, Simulationen und Visualisierungen eingesetzt.\n\nEin Jupyter Notebook besteht aus einer Abfolge von Zellen, in denen Text,\nCode oder Grafiken eingebettet werden. Die Zellen können entweder in Python oder\nin anderen Programmiersprachen wie R, Julia oder JavaScript geschrieben sein.\nErkennbar sind Jupyter Notebooks an der Dateiendung .ipynb.\n\nDie Kombination von Text, Code und Visualisierungen macht Jupyter Notebooks zu\neinem besonders geeigneten Werkzeug für das Programmierenlernen: Konzepte\nwerden im Text erläutert und können direkt in Code-Zellen ausprobiert werden.\n\n\n\nFigure 1:Screenshot eines Jupyter Notebooks mit Text, Python-Code und Ergebnissen des\nausgeführten Python-Codes, das mit der “JupyterLab” geladen wurde (Quelle:\neigene Darstellung; Lizenz \n\nCC BY-NC-SA\n4.0)\n\nEine Zelle kann entweder eine Text-Zelle (siehe Screenshot, Schritt 1) oder eine\nCode-Zelle (siehe Screenshot, Schritt 2) sein. In Text-Zellen wird die\n\n\nMarkdown​-Formatierung\nverwendet. Um ein Wort fettgedruckt anzuzeigen, schreibt man zum Beispiel\n**fett**, was als fett dargestellt wird. In Code-Zellen (siehe Screenshot,\nSchritt 2 oder 3) können Sie direkt Python-Code eingeben. Eine Code-Zelle wird\nausgeführt, indem Sie auf “Run” klicken (siehe Screenshot, Schritt 4). Danach\nerscheint die Ausgabe, die der Python-Interpreter ggf. erzeugt (siehe\nScreenshot, Schritt 5). Ergebnisse werden mit “Out” gekennzeichnet.","type":"content","url":"/chapter01-sec02#was-sind-jupyter-notebooks","position":5},{"hierarchy":{"lvl1":"1.2 Jupyter Notebooks und Python als Taschenrechner","lvl2":"Python als Taschenrechner"},"type":"lvl2","url":"/chapter01-sec02#python-als-taschenrechner","position":6},{"hierarchy":{"lvl1":"1.2 Jupyter Notebooks und Python als Taschenrechner","lvl2":"Python als Taschenrechner"},"content":"Bevor wir in die Programmierung einsteigen, benutzen wir Python erst einmal als\nTaschenrechner. Im Folgenden sehen Sie, wie die Grundrechenarten in Python\nverwendet werden:\n\nAddition:\n\n2+3\n\n\n\nSubtraktion:\n\n2-3\n\n\n\nMultiplikation:\n\n2*4\n\n\n\nDivision:\n\n8/2\n\n\n\nPotenzierung:\n\n3**2\n\n\n\nSie können die obigen Code-Zellen verändern, zum Beispiel 2 + 3 in 2 + 5\nändern. So lernen Sie den Umgang mit Python-Anweisungen kennen.\n\nWenn Sie dieses Skript als interaktives Jupyter Notebook öffnen, können Sie\ndirekt in die Zellen klicken und den Code ändern. Falls Sie das Skript online\nlesen, klicken Sie bitte auf das Raketensymbol oben rechts und wählen „Live\nCode“, um interaktive Zellen zu aktivieren. Beim ersten Start kann dies etwas\ndauern.\n\nUm Übungen zu ermöglichen, enthalten manche Zellen nur einen Kommentar als\nPlatzhalter:\n\n# Geben Sie nach diesem Kommentar Ihren Code ein:\n\n\n\nAlles was nach dem Hashtag # steht, ist ein Kommentar. Kommentare werden von\nPython ignoriert und sind nur für uns Menschen gedacht.\n\nSelbstverständlich beherrscht Python auch Klammerregeln. Probieren Sie es aus!\n\nMini-Übung\n\nLassen Sie Python den Term 3\\cdot (7-10)+5 berechnen.\n\n# Geben Sie nach diesem Kommentar Ihren Code ein:\n\n\n\nLösung3 * (7-10) + 5","type":"content","url":"/chapter01-sec02#python-als-taschenrechner","position":7},{"hierarchy":{"lvl1":"1.2 Jupyter Notebooks und Python als Taschenrechner","lvl2":"Ausgaben mit print"},"type":"lvl2","url":"/chapter01-sec02#ausgaben-mit-print","position":8},{"hierarchy":{"lvl1":"1.2 Jupyter Notebooks und Python als Taschenrechner","lvl2":"Ausgaben mit print"},"content":"Bei den obigen Rechenaufgaben wurde automatisch das Ergebnis der Rechnung\nangezeigt, sobald die Code-Zelle ausgeführt wurde. Dies ist eine Besonderheit\nder Jupyter Notebooks. In einem normalen Python-Programm würde das nicht\nfunktionieren. Die interaktive Ausgabe der Jupyter Notebooks zeigt außerdem\nimmer nur das Ergebnis der letzten Zeile an.\n\nUm beliebige Ergebnisse oder Texte gezielt auszugeben, gibt es die\nprint()-Funktion.\n\nprint(2)\nprint(3+3)\n\n\n\nDas Argument wird in runde Klammern hinter den Funktionsnamen print\ngeschrieben. Ein Argument ist sozusagen der Input, der an die Funktion übergeben\nwird, damit Python weiß, welcher Wert auf dem Bildschirm angezeigt werden soll.\n\nDas zweite Beispiel in der zweiten Zeile funktioniert genauso. Nur wird diesmal\neine komplette Rechnung als Argument an die print()-Funktion übergeben. In dem\nFall rechnet der Python-Interpreter erst den Wert der Rechnung, also 3+3=6 aus\nund übergibt dann die 6 an die print()-Funktion. Die print()-Funktion\nwiederum zeigt dann die 6 am Bildschirm an.\n\nInsgesamt zeigt daher der Python-Interpreter erst eine 2 und dann in der\nnächsten Zeile eine 6 an.\n\nMini-Übung\n\nLassen Sie Python den Term 3:4 berechnen und geben Sie das Ergebnis mit der\nprint()-Funktion aus.\n\n# Geben Sie nach diesem Kommentar Ihren Code ein:\n\n\n\nLösungprint(3/4)\n\nAchtung: In Python wird für die Division / verwendet, nicht :. Das ist ein\nhäufiger Fehler.\n\nPython kann mit der print()-Funktion jedoch nicht nur Zahlen ausgeben, sondern\nauch Texte. Ein erster Versuch, einfach den Text als Argument der\nprint()-Funktion zu übergeben, scheitert leider, wie das nächste Beispiel zeigt.\n\n# Achtung, die nachfolgende Code-Zeile enthält einen Fehler!\nprint(Hallo)\n\n\n\nEs erscheint eine Fehlermeldung mit dem Fehler: NameError: name 'Hallo' is not defined. Der Grund hierfür ist, dass der Python-Interpreter versucht, eine\nsogenannte Variable oder eine Python-Anweisung mit dem Namen Hallo zu finden.\nDa es aber keines von beiden gibt, kommt die Fehlermeldung, dass Hallo nicht\ndefiniert wurde. Um den Text ausgeben zu lassen, werden um den Text einfache\noder doppelte Anführungszeichen gesetzt, wie in dem folgenden Beispiel.\n\nprint('Hallo')\n\n\n\nMini-Übung\n\nProbieren Sie aus was passiert, wenn Sie die einfachen Anführungszeichen '\ndurch doppelte Anführungszeichen \" ersetzen. Lassen Sie den Text Hallo Welt\nausgeben.\n\n# Geben Sie nach diesem Kommentar Ihren Code ein:\n\n\n\nLösungprint(\"Hallo Welt\")\n\nIn Python sind sowohl einfache als auch doppelte Anführungszeichen erlaubt.\nWenn ein Apostroph im Text vorkommt, sollten Sie doppelte Anführungszeichen\nverwenden.\n\nDie print()-Funktion kann noch viel mehr, als wir in dieser Einführung\ngesehen haben. Wir werden in einem späteren Kapitel im Zusammenhang mit den\nsogenannten f-Strings nochmal darauf zurückkommen.\n\nHinweis: Das folgende Video nutzt eine andere Entwicklungsumgebung (PyCharm) als\nwir in dieser Vorlesung. Wir nutzen die Entwicklungsumgebung JupyterLab. Die\ngrundlegenden Python-Befehle sind jedoch identisch. Fokussieren Sie sich ab\nMinute 9 auf die Python-Syntax, nicht auf die Bedienung der Software.\n\nVideo “Dein erstes Python-Programm” von Programmieren Starten","type":"content","url":"/chapter01-sec02#ausgaben-mit-print","position":9},{"hierarchy":{"lvl1":"1.2 Jupyter Notebooks und Python als Taschenrechner","lvl2":"Zusammenfassung und Ausblick"},"type":"lvl2","url":"/chapter01-sec02#zusammenfassung-und-ausblick","position":10},{"hierarchy":{"lvl1":"1.2 Jupyter Notebooks und Python als Taschenrechner","lvl2":"Zusammenfassung und Ausblick"},"content":"In diesem Kapitel haben wir Jupyter Notebooks kennengelernt, Python als\nTaschenrechner genutzt und die erste Python-Anweisung print() eingesetzt. Im\nnächsten Kapitel geht es um das Speichern von Daten und deren Verwaltung.","type":"content","url":"/chapter01-sec02#zusammenfassung-und-ausblick","position":11},{"hierarchy":{"lvl1":"Übungen"},"type":"lvl1","url":"/chapter01-sec03","position":0},{"hierarchy":{"lvl1":"Übungen"},"content":"Übung 1.1\n\nInstallieren Sie Anaconda auf Ihrem System. Starten Sie JupyterLab und erstellen\nSie ein neues Notebook. Bei Problemen konsultieren Sie die\nInstallationsanleitung.\n\nÜbung 1.2\n\nBenutzen Sie Python als Taschenrechner. Fügen Sie dazu diesem Jupyter Notebook\neine Code-Zelle hinzu und lassen Sie die folgenden Ausdrücke berechnen:\n\n2 + 3\n\n2 - 3\n\n4 * 5\n\n16 / 4\n\n16 / 3\n\n5**2\n\nLösungprint(2+3)\nprint(2-3)\nprint(4*5)\nprint(16/4)\nprint(16/3)\nprint(5**2)\n\nÜbung 1.3\n\nIn der vorhergehenden Aufgabe haben Sie den Ausdruck 5**2 berechnen lassen.\nFügen Sie jetzt eine Markdown-Zelle ein. Schreiben Sie auf, was Ihrer Vermutung\nnach der **-Operator für eine Bedeutung hat. Recherchieren Sie anschließend im\nInternet, nach seiner Bedeutung und vergleichen Sie Ihre Antwort mit der Recherche.\nFügen Sie die Internetseite als URL in die Markdown-Zelle ein.\n\nLösung\n\nDie beiden Sterne ** stehen für das Potenzieren. Eine kurze Beschreibung findet sich hier:\n[\n\nhttps://​www​.w3schools​.com​/python​/gloss​_python​_arithmetic​_operators​.asp]\n\nÜbung 1.4\n\nSpeichern Sie das bearbeitete Jupyter Notebook unter einem anderen Namen ab.\n\nLösung\n\nSehen Sie sich den folgenden Screencast an.\n\n\nÜbung 1.5\n\nProbieren Sie bewusst falsche Python-Anweisungen aus und beobachten Sie die\nFehlermeldungen.\n\nGeben Sie print(Hallo Welt) ein (ohne Anführungszeichen).\n\nVersuchen Sie 2 +* 3 (falsche Operatorenkombination).\n\nSchreiben Sie Print(5) (großes P) .\n\nNotieren Sie in einer Markdown-Zelle, welche Fehlermeldungen erscheinen und was\nsie bedeuten könnten.\n\nLösung\n\nprint(Hallo Welt) ohne Anführungszeichen führt zu der Fehlermeldung\nSyntaxError: invalid syntax. Syntax ist der Fachbegriff für die Grammatik\neiner Sprache. Diese Anweisung ist ungültig, weil Hallo Welt nicht als\nString gekennzeichnet wurde, also in Anführungszeichen gesetzt wurde.\n\nDie Anweisung 2 +* 3 führt ebenfalls zu einem Grammatikfehler, also\nSyntaxError: invalid syntax.\n\nDie Anweisung Print(5) führt zu einem Namensfehler NameError: name 'Print' is not defined. Python achtet penibel auf Groß- und Kleinschreibung. Den\nBefehl Print() mit einem großem P kennt Python daher nicht und meldet\ndeshalb den NameError.\n\nÜbung 1.6\n\nErstellen Sie eine Code-Zelle mit folgendem Inhalt:# Das ist ein Kommentar\nprint(7 + 3)  # Hier wird 7 + 3 berechnet\n# print(5 * 2)\nprint(8 - 2)\n\nFühren Sie die Zelle aus. Erklären Sie in einer Markdown-Zelle, warum manche\nZeilen ausgeführt werden und andere nicht.\n\nLösung\n\nEs werden nur die Zeilen ausgeführt, in denen kein Kommentarzeichen #\nsteht.\n\nÜbung 1.7\n\nBerechnen Sie folgende Ausdrücke und vergleichen Sie die Ergebnisse:\n\n2 + 3 * 4\n\n(2 + 3) * 4\n\n2**3*4\n\n2**(3*4)\n\nSchreiben Sie in eine Markdown-Zelle, welche Regeln Python für die Reihenfolge\nder Operationen befolgt.\n\nLösung\n\nEs gelten die folgenden Regeln für die Reihenfolge der Operationen:\n\nPunkt- vor Strichrechnung (als erst * und \\ vor + und -).\n\nKlammern werden immer zuerst berechnet.\n\nPotenzen werden vor +, -, *, \\ berechnet. Erst wird \n\n23 berechnet,\nwas 8 ergibt, und dann mit 4 multipliziert, so dass das Endergebnis 32 ist.\nDas Endergebnis ist nicht 2^{12} = 4096.\n\nKlammern werden weiterhin zuerst berechnet, also vor der Potenzierung\nausgewertet. Das Ergebnis ist 4096.\n\nÜbung 1.8\n\nExperimentieren Sie mit der print()-Funktion:\n\nprint(\"Mein Name ist\", \"Max\")\n\nprint(\"Das Ergebnis ist:\", 5*6)\n\nprint(2, 4, 6, 8)\n\nWas beobachten Sie, wenn print() mehrere Argumente erhält?\n\nLösung\n\nWerden der print()-Anweisung zwei Argumente übergeben, werden beide Argumente\nin einer Zeile angezeigt. Das Komma, das die beiden Argumente trennt, wird nicht\nausgegeben. Aus  print(\"Mein Name ist\", \"Max\") wird also der Text Mein Name ist Max. Das funktioniert auch bei Zahlen und sogar Rechnungen. Aus print(\"Das Ergebnis ist:\", 5*6) wird Das Ergebnis ist: 30.\n\nPython lässt in der print()-Funktion beliebig viele Argumente zu. Auch\nbeispielsweise vier Argumente wie in der Anweisung print(2, 4, 6, 8)\nfunktionieren, die Ausgabe ist 2 4 6 8.\n\nÜbung 1.9\n\nBerechnen Sie mit Python typische Ingenieursaufgaben, z.B.\n\nden Umfang eines Kreises mit Radius 5 cm (U = 2\\pi r, verwenden Sie \\pi\n\\approx 3.14159),\n\ndie Fläche eines Rechtecks mit Länge 12 m und Breite 8 m oder\n\ndie Geschwindigkeit eines Autos bei gleichförmiger Bewegung mit Weg 150 km in\nZeit 2.5 h.\n\nVerwenden Sie print() um die Ergebnisse mit beschreibendem Text auszugeben.\nWie kann Ihnen die vorherige Aufgabe dabei helfen?\n\nLösungprint('Der Umfang des Kreises mit r =', 5, 'ist', 2 * 5 * 3.14159, '.')\nprint('Die Fläche des Rechtecks mit Seite a =', 12, 'und Seite b =', 8, 'ist', 12*8, '.')\nprint('Die Geschwindigkeit ist', 150/2.5, 'km/h, wenn s =', 150, 'km und t =', 2.5, 'h .')","type":"content","url":"/chapter01-sec03","position":1},{"hierarchy":{"lvl1":"2.1 Datentypen und Variablen"},"type":"lvl1","url":"/chapter02-sec01","position":0},{"hierarchy":{"lvl1":"2.1 Datentypen und Variablen"},"content":"Mit Zahlen wird anders umgegangen, als mit Texten. Zahlen werden beispielsweise\naddiert, bei Texten werden beispielsweise Kleinbuchstaben durch Großbuchstaben\nersetzt. Daher ist es nicht verwunderlich, dass Python für beide Arten von\nInformationen eine andere technische Umsetzung verwendet. Das führt zu dem Thema\nDatentypen und dem Speichern von Informationen in Variablen.","type":"content","url":"/chapter02-sec01","position":1},{"hierarchy":{"lvl1":"2.1 Datentypen und Variablen","lvl2":"Lernziele"},"type":"lvl2","url":"/chapter02-sec01#lernziele","position":2},{"hierarchy":{"lvl1":"2.1 Datentypen und Variablen","lvl2":"Lernziele"},"content":"Lernziele\n\nSie wissen, was Datentypen sind.\n\nSie kennen den Unterschied zwischen Ganzzahlen und\nFließkommazahlen und die dazugehörigen Datentypen Integer und\nFloat.\n\nSie kennen den Datentyp String, der Zeichenketten repräsentiert.\n\nSie wissen, was eine Variable ist und wie sie erzeugt und gefüllt\nwird.","type":"content","url":"/chapter02-sec01#lernziele","position":3},{"hierarchy":{"lvl1":"2.1 Datentypen und Variablen","lvl2":"Datentypen in Python"},"type":"lvl2","url":"/chapter02-sec01#datentypen-in-python","position":4},{"hierarchy":{"lvl1":"2.1 Datentypen und Variablen","lvl2":"Datentypen in Python"},"content":"Der Computer kann Informationen nur als 0 oder 1 verarbeiten. Auf dem\nSpeichermedium oder im Speicher selbst werden Daten daher als eine Folge von 0\nund 1 gespeichert. Damit es für uns Programmiererinnen und Programmierer\neinfacher wird, Daten zu speichern und zu verarbeiten, wurden Datentypen\neingeführt.\n\nDatentypen fassen gleichartige Objekte zusammen und stellen passende\nOperationen zur Verfügung. Es hängt von der Programmiersprache ab, welche\nDatentypen zur Verfügung stehen, wie diese im Hintergrund gespeichert werden\nund welche Operationen damit möglich sind. In diesem Kapitel beschäftigen wir\nuns mit den einfachen Datentypen\n\nInteger\n\nFloat\n\nString","type":"content","url":"/chapter02-sec01#datentypen-in-python","position":5},{"hierarchy":{"lvl1":"2.1 Datentypen und Variablen","lvl3":"Zahlen (Integer und Floats)","lvl2":"Datentypen in Python"},"type":"lvl3","url":"/chapter02-sec01#zahlen-integer-und-floats","position":6},{"hierarchy":{"lvl1":"2.1 Datentypen und Variablen","lvl3":"Zahlen (Integer und Floats)","lvl2":"Datentypen in Python"},"content":"In der Programmierung unterscheidet man grundsätzlich zwischen zwei Zahlenarten,\nden Ganzzahlen und den Fließkommazahlen. Die Ganzzahlen werden in der\nMathematik als ganze Zahlen bezeichnet. In der Informatik wird meist der\nenglische Begriff Integer verwendet. Mit Integern können wir rechnen, d.h.\nOperationen ausführen. Einige davon haben wir ja bereits ausprobiert, als wir\nPython als Taschenrechner benutzt haben:\n\n2 * (3 + 4)\n\n\n\nSobald wir eine Division durchführen, die nicht aufgeht wie beispielsweise 1/2,\nverlassen wir den Bereich der ganzen Zahlen und kommen automatisch zu den\nrationalen Zahlen. Die rationalen Zahlen werden in der Informatik als\nFließkommazahl bzw. als Float bezeichnet. Python verwendet für das Ergebnis\neiner Division immer einen Float, unabhängig davon, ob die Division ganzzahlig\ndurchführbar wäre oder nicht, wie wir hier sehen:\n\n10/5\n\n\n\nHinweis: Das Dezimaltrennzeichen ist ein Punkt, nicht ein Komma wie im\nDeutschen. Aber ansonsten funktioniert alles wie erwartet:\n\n2.3 + 4.6\n\n\n\n1.4 - 5.2\n\n\n\n(-3.8) * 3.1\n\n\n\n2.4 / 0.3\n\n\n\n2.5**10\n\n\n\nMini-Übung\n\nEin zylindrischer Wassertank hat einen Radius von 1.5 m und eine Höhe von 4.0 m.\nBerechnen Sie sein Volumen mit der Formel V = \\pi \\cdot r^2 \\cdot h. Verwenden\nSie für die Kreiszahl \\pi die Näherung \\pi = 3.14159.\n\n# Code-Zelle\n\n\n\nLösung3.14159 * 1.5 * 1.5 * 4.0\n\nDas folgende Video fasst Zahlen in Python zusammen.\n\nVideo “Zahlen in Python” von Programmieren Starten","type":"content","url":"/chapter02-sec01#zahlen-integer-und-floats","position":7},{"hierarchy":{"lvl1":"2.1 Datentypen und Variablen","lvl3":"Strings","lvl2":"Datentypen in Python"},"type":"lvl3","url":"/chapter02-sec01#strings","position":8},{"hierarchy":{"lvl1":"2.1 Datentypen und Variablen","lvl3":"Strings","lvl2":"Datentypen in Python"},"content":"Daten sind aber sehr oft keine Zahlen. Beispielsweise könnte man sich\nvorstellen, eine Einkaufsliste zu erstellen und diese im Computer oder in einer\nNotiz-App auf dem Handy zu speichern. Eine solche Zeichenkette heißt in der\nInformatik String. Mit Zeichen meint man dabei Zahlen, Buchstaben oder\nandere Zeichen wie beispielsweise !\"§$%&/()=?.\n\nStrings werden in Python durch einfache oder doppelte Anführungszeichen definiert:\n\n\"Dies ist ein String!\"\n\n\n\nStrings haben wir beim Hallo-Welt-Programm schon kennengelernt. Allerdings haben\nwir zu diesem Zeitpunkt noch nicht den korrekten Fachbegriff String verwendet,\nsondern sie als Texte bezeichnet.\n\nWenn wir versuchen, zwei Strings zu addieren, passiert etwas Überraschendes.\n\n'2' + '2'\n\n\n\nDer +-Operator bewirkt bei Strings, dass sie zu einem neuen String verkettet\n(hintereinander gehängt) werden. Auch wenn das zunächst unerwartet ist, ist die\nVerkettung sehr nützlich, wenn wir einen String aus mehreren Strings\nzusammensetzen möchten:\n\nprint('Name: ' + 'Anna' + ' ' + 'Abendrot')\n\n\n\nAuf Strings und ihre Anwendungen kommen wir später noch zurück. Wenn Sie bereits\njetzt mehr erfahren wollen, können Sie sich folgendes Video ansehen.\n\nVideo “Strings in Python” von Programmieren Starten\n\nDie folgende Tabelle und das Video fassen die drei Datentypen Integer, Float und String\nübersichtsartig zusammen:\n\nDatentyp\n\nBeispiele\n\nTypische Operationen\n\nInteger\n\n42, -17, 0\n\n+, -, *, **\n\nFloat\n\n3.14, -0.5, 2.0\n\n+, -, *, /, **\n\nString\n\n\"Hallo\", 'Python'\n\n+ (Verkettung)\n\nVideo “Datentypen in Python” von Programmieren Starten","type":"content","url":"/chapter02-sec01#strings","position":9},{"hierarchy":{"lvl1":"2.1 Datentypen und Variablen","lvl2":"Variablen"},"type":"lvl2","url":"/chapter02-sec01#variablen","position":10},{"hierarchy":{"lvl1":"2.1 Datentypen und Variablen","lvl2":"Variablen"},"content":"Variablen sind beschriftete Schubladen. Oder anders formuliert sind\nVariablen Objekte, denen man einen Namen gibt. Technisch gesehen sind diese\nSchubladen ein kleiner Bereich im Arbeitsspeicher des Computers. Was in diesen\nSchubladen aufbewahrt wird, kann sehr unterschiedlich sein. Beispielsweise die\nTelefonnummer des ADAC-Pannendienstes, die 10. Nachkommastelle von \\pi oder die\naktuelle Position des Mauszeigers können in den Schubladen enthalten sein.\n\nWir verwenden Variablen, um bestimmte Werte oder ein bestimmtes Objekt zu\nspeichern. Eine Variable wird durch Zuweisung erzeugt. Damit meinen wir,\ndass eine Schublade angelegt wird und die Schublade dann erstmalig gefüllt wird.\nDas erstmalige Füllen der Schublade nennt man in der Informatik auch\nInitialisieren.\n\nx = 0.5\n\n\n\nSobald die Variable x in diesem Beispiel durch eine Zuweisung von 0.5 erstellt\nwurde, können wir sie verwenden:\n\nx * 3\n\n\n\nx + 17.8\n\n\n\nVariablen müssen initialisiert (erstmalig mit einem Wert versehen) werden, bevor\nsie verwendet werden können, sonst tritt ein Fehler auf.\n\nMini-Übung\n\nSpeichern Sie die Erdbeschleunigung 9.81 \\frac{\\text{m}}{\\text{s}^2} in einer\nVariable und berechnen Sie die Gewichtskraft eines 75 kg schweren Objekts mit\nFormel: F = m \\cdot g.\n\n# Code-Zelle\n\n\n\nLösungg = 9.81\n75 * g\n\nGerne können Sie sich auch folgendes Video auf YouTube ansehen, das eine\nEinführung in das Thema Variablen in Python gibt.\n\nVideo “Variablen in Python” von Programmieren Starten","type":"content","url":"/chapter02-sec01#variablen","position":11},{"hierarchy":{"lvl1":"2.1 Datentypen und Variablen","lvl2":"Richtlinien für Variablennamen"},"type":"lvl2","url":"/chapter02-sec01#richtlinien-f-r-variablennamen","position":12},{"hierarchy":{"lvl1":"2.1 Datentypen und Variablen","lvl2":"Richtlinien für Variablennamen"},"content":"Früher war der Speicherplatz von Computern klein, daher wurden häufig nur kurze\nVariablennamen wie beispielsweise i oder N verwendet. Heutzutage ist es\nStandard, nur in Ausnahmefällen (z.B. in Schleifen, dazu kommen wir noch) kurze\nVariablennamen zu nehmen. Stattdessen werden Namen benutzt, bei denen man\nerraten kann, was die Variable für einen Einsatzzweck hat. Beispielsweise lässt\nder Code\n\nm = 0.19\nn = 80\nb = n + m * n\nprint(b)\n\n\n\nnur schwer vermuten, was damit bezweckt wird. Oder können Sie erahnen, was dort\npassieren soll? Dagegen erahnt man bei diesem Code schon eher, was bezweckt\nwird:\n\nmehrwertsteuersatz = 19/100\nnettopreis = 80\nbruttopreis = nettopreis + mehrwertsteuersatz * nettopreis\nprint(bruttopreis)\n\n\n\nVerwenden Sie für Variablennamen nur ASCII-Zeichen, also keine Umlaute wie ö,\nü oder ß. Zahlen sind erlaubt, aber nicht am Anfang des Namens. Es ist\nsinnvoll, lange Variablen durch einen Unterstrich besser lesbar zu gestalten\n(sogenannte Snake-Case-Formatierung). Ich empfehle für Variablennamen\nbeispielsweise dateiname_alt oder dateiname_neu, wenn beispielsweise eine\nDatei umbenannt wird. Sie sind frei in der Gestaltung der Variablennamen,\nverboten sind nur die sogenannten Schlüsselwörter. Schlüsselwörter sind\nbeispielsweise eingebaute Kommandos für den Python-Interpreter wie if, for,\nwhile, def, class oder print. Würden Sie diese als Variablennamen\nbenutzen, wüsste der Python-Interpreter nicht, ob das Kommando oder die Variable\ngemeint ist.\n\nMini-Übung\n\nEin Elektromotor hat eine Leistung von 2500 Watt und läuft 8 Stunden pro Tag.\nBerechnen Sie den Energieverbrauch in Kilowattstunden (kWh) gemäß der Formel: E\n= P \\cdot t, wobei die Variablen folgende Bedeutung haben:\n\nVariable\n\nBedeutung\n\nEinheit\n\nE\n\nEnergieverbrauch\n\nkWh\n\nP\n\nLeistung\n\nkW\n\nt\n\nZeit\n\nh\n\nBeachten Sie, dass die Leistung in Watt zunächst in kW umgerechnet\nwerden muss.\n\n# Code-Zelle\n\n\n\nLösungleistung_watt = 2500\nleistung_kw = leistung_watt / 1000\nlaufzeit_stunden = 8\nenergie_kwh = leistung_kw * laufzeit_stunden\nprint(energie_kwh)","type":"content","url":"/chapter02-sec01#richtlinien-f-r-variablennamen","position":13},{"hierarchy":{"lvl1":"2.1 Datentypen und Variablen","lvl2":"Zusammenfassung und Ausblick"},"type":"lvl2","url":"/chapter02-sec01#zusammenfassung-und-ausblick","position":14},{"hierarchy":{"lvl1":"2.1 Datentypen und Variablen","lvl2":"Zusammenfassung und Ausblick"},"content":"In diesem Kapitel haben wir uns mit der Verarbeitung (Datentypen und Speichern\nvon Werten in Variablen) und der Ausgabe beschäftigt. Im nächsten Kapitel werden\nwir uns zusätzlich mit der Eingabe beschäftigen und so das komplette EVA-Prinzip\nvon datenverarbeitenden Systemen kennenlernen: Eingabe - Verarbeitung - Ausgabe.","type":"content","url":"/chapter02-sec01#zusammenfassung-und-ausblick","position":15},{"hierarchy":{"lvl1":"2.2 Benutzereingaben"},"type":"lvl1","url":"/chapter02-sec02","position":0},{"hierarchy":{"lvl1":"2.2 Benutzereingaben"},"content":"Ohne die Eingabe von Daten sind Apps wertlos. In diesem Kapitel beschäftigen wir\nuns daher mit einer direkten Eingabemöglichkeit in Python und lernen dazu die\ninput()-Funktion kennen. Um die input()-Funktion korrekt zu nutzen\nbeschäftigen wir uns mit Umwandlungen von Datentypen in andere Datentypen.\nZuletzt gehen wir noch auf die Stolperfalle ein, dass der Zuweisungsoperator =\nnicht die mathematische Gleichheit überprüft.","type":"content","url":"/chapter02-sec02","position":1},{"hierarchy":{"lvl1":"2.2 Benutzereingaben","lvl2":"Lernziele"},"type":"lvl2","url":"/chapter02-sec02#lernziele","position":2},{"hierarchy":{"lvl1":"2.2 Benutzereingaben","lvl2":"Lernziele"},"content":"Lernziele\n\nSie können das EVA-Prinzip erklären.\n\nSie können mit der input()-Funktion die Eingabe eines Benutzers abfragen\nund weiter verarbeiten.\n\nSie können per Typecasting Datentypen in andere Datentypen umwandeln.\n\nSie können mit der Funktion type() den Datentyp einer Variable\nermitteln.\n\nSie wissen, dass das Zeichen = ein Zuweisungsoperator ist und nicht für\ndie mathematische Gleichheit zweier Ausdrücke steht.","type":"content","url":"/chapter02-sec02#lernziele","position":3},{"hierarchy":{"lvl1":"2.2 Benutzereingaben","lvl2":"Ein- und Ausgabe sowie das EVA-Prinzip"},"type":"lvl2","url":"/chapter02-sec02#ein-und-ausgabe-sowie-das-eva-prinzip","position":4},{"hierarchy":{"lvl1":"2.2 Benutzereingaben","lvl2":"Ein- und Ausgabe sowie das EVA-Prinzip"},"content":"Grundlegend geht es bei der Datenverarbeitung und insbesondere bei der\nwissenschaftlichen Programmierung darum, Daten zu verarbeiten. Selbst bei einer\nSmartphone-App zum Spielen müssen Daten verarbeitet werden. Beispielsweise\nwerden das aktuelle Level oder die momentane Position des Gegners ausgewertet\nund gespeichert. Grundsätzlich folgen datenverarbeitende Systeme dem sogenannten\nEVA-Prinzip.\n\nWikipedia beschreibt das \n\nEVA-Prinzip wie folgt:\n\n“...Das EVA-Prinzip beschreibt ein Grundprinzip der Datenverarbeitung. Die\nAbkürzung leitet sich aus den ersten Buchstaben der Begriffe Eingabe,\nVerarbeitung und Ausgabe ab (englisch IPO model: input-process-output). Diese\ndrei Begriffe beschreiben die Reihenfolge, in der Daten verarbeitet werden.”\n\nTypische Eingabe-Operationen sind dabei\n\ndie Eingabe von Zeichen über eine Tastatur oder\n\ndas Lesen von Dateien, die auf der Festplatte oder einem Speichermedium gespeichert sind.\n\nHäufige Ausgabe-Operationen sind\n\ndie Wiedergabe von Texten, Zahlen oder Bildern auf dem Bildschirm oder\n\ndas Schreiben von Dateien auf Festplatte oder Speichermedium.\n\nMit der Ausgabe print() haben wir uns schon beschäftigt. Als nächstes geht es\num die Eingabe.","type":"content","url":"/chapter02-sec02#ein-und-ausgabe-sowie-das-eva-prinzip","position":5},{"hierarchy":{"lvl1":"2.2 Benutzereingaben","lvl2":"Die input()-Funktion"},"type":"lvl2","url":"/chapter02-sec02#die-input-funktion","position":6},{"hierarchy":{"lvl1":"2.2 Benutzereingaben","lvl2":"Die input()-Funktion"},"content":"Die einfachste und häufigste Eingabe erfolgt über die Tastatur. Die Funktion\ninput() stoppt das laufende Skript und erwartet eine Eingabe über die\nTastatur. Dabei wird der Text angezeigt, der zwischen den einfachen\nAnführungszeichen steht. Bei Python wird die Eingabe als String interpretiert.\nDie Eingabe wird mit der Taste Return/Enter abgeschlossen. Probieren wir es aus\n(dazu muss die Markdown-Zelle noch in eine Code-Zelle umgewandelt werden):input('Bitte geben Sie Ihren Namen ein: ')\n\nWir haben zwar jetzt auf Aufforderung einen Namen eingegeben, aber verarbeitet\nwurde diese Eingabe nicht. Es passierte einfach nichts. Um die Eingabe\nverarbeiten zu können, speichern wir sie zunächst in einer Variablen ab.x = input('Bitte geben Sie Ihren Namen ein: ')\n\nJetzt haben wir zwar den Namen in einer Variable gespeichert, aber so richtig\npassiert ist immer noch nichts. Jetzt wäre es noch schön, wenn wir den Benutzer\noder die Benutzerin unseres Skripts begrüßen können und einen entsprechenden Text\nanzeigen lassen können. Dazu verwenden wir erneut die print()-Funktion.print('Hallo')\n\nJetzt können wir alles zusammensetzen.# Eingabe\nx = input('Bitte geben Sie Ihren Namen ein: ')\n\n# Ausgabe\nprint('Hallo ' + x)\n\nKopieren Sie diesen Code in die nächste Code-Zelle und probieren Sie es aus!\n\n# Code-Zelle\n\n\n\nMini-Übung\n\nSchreiben Sie ein Programm, das nach Ihrem Lieblingsgericht fragt und dann\nausgibt: “Ihr Lieblingsgericht ist: [Eingabe]”.\n\n# Code-Zelle\n\n\n\nLösung# Eingabe\nlieblingsgericht = input('Was ist Ihr Lieblingsgericht? ')\n\n# Ausgabe\nprint('Ihr Lieblingsgericht ist ' + lieblingsgericht)\n\nIn dem folgenden Video sehen Sie weitere Erläuterungen zur input()-Funktion.\n\nVideo “Die input()-Funktion” von Programmieren Starten","type":"content","url":"/chapter02-sec02#die-input-funktion","position":7},{"hierarchy":{"lvl1":"2.2 Benutzereingaben","lvl2":"Umwandlung von Datentypen"},"type":"lvl2","url":"/chapter02-sec02#umwandlung-von-datentypen","position":8},{"hierarchy":{"lvl1":"2.2 Benutzereingaben","lvl2":"Umwandlung von Datentypen"},"content":"Die input()-Funktion hat eine Einschränkung. Bei ihrer Einführung wurde in\neinem Nebensatz erwähnt, dass die input()-Funktion Strings zurückgibt. Python\nkann bei der Eingabe nicht wissen, ob wir eine Zahl oder Text eingeben möchten,\ndaher wird alles als Text (String) behandelt. Das ist eine häufige Fehlerquelle\nin der Programmierung, wenn man nach Zahlen fragt. Glücklicherweise gibt es\ndafür eine einfache Lösung. Wir können einen String in einen Integer oder Float\numwandeln, indem wir die Funktionen int() oder float() benutzen. Wenn also\nnach einer Zahl gefragt werden soll wie beispielsweise dem Alter einer Person,\nso lautet der Code wie folgt:# Eingabe: input() liefert String\nantwort = input('Wie alt sind Sie?') \n\n# Verarbeitung: Umwandlung in einen Integer  \nzahl = int(antwort)\n\n# Ausgabe                \nprint('Alter: ', zahl)                \n\nUnd soll es eine Fließkommazahl werden, können wir folgendermaßen vorgehen:# Eingabe: input() liefert String\nantwort = input('Wie groß sind Sie gemessen in Metern?')\n\n# Verarbeitung: Umwandlung in einen Float\nzahl = float(antwort)\n\n# Ausgabe    \nprint('Größe in m', zahl)\n\nProbieren Sie gerne beide Varianten in der nächsten Code-Zelle aus.\n\n# Code-Zelle\n\n\n\nWarnung\n\nWenn Sie bei int() oder float() keine gültige Zahl eingeben, meldet Python\neinen Fehler (ValueError). Geben Sie also bei der Abfrage nach dem Alter\nwirklich eine Zahl ein!\n\nMöchten wir Zahlen mit ihrer Einheit ausgeben, können wir umgekehrt die Zahl in\neinen String umwandeln, indem wir str() benutzen.\n\ng = 9.81\nprint('Die Erdbeschleunigung g = ' + str(g) + 'm/s^2.')\n\n\n\nMini-Übung\n\nSchreiben Sie ein Programm, das nach einer Temperatur in Grad Celsius fragt und\ndiese in Kelvin umrechnet. Formel: K = C + 273.15\n\nBeispiel: Eingabe 20 ==> Ausgabe “20.0°C entspricht 293.15 K”\n\n# Code-Zelle\n\n\n\nLösung# Eingabe\ntemperatur_C = float(input('Geben Sie die Temperatur in Grad Celsius an: '))\n\n# Verarbeitung\ntemperatur_K = temperatur_C + 273.15\n\n# Ausgabe\nprint(str(temperatur_C) + '°C entspricht ' + str(temperatur_K) + ' K.')\n\nIn den bisher betrachteten Beispielen sind die Python-Programme ein bis zwei\nZeilen lang. Unwahrscheinlich, dass dann nicht klar ist, welchen Datentyp eine\nVariable hat. Wenn aber später die Programme länger werden und vielleicht auch\nBenutzereingaben dazu kommen, kann man auch den Überblick darüber verlieren,\nwelcher Datentyp aktuell in einer bestimmten Variable gespeichert ist. Dafür\ngibt es die type()-Funktion.\n\ndatentyp = type(3)\nprint(datentyp)\n\ndatentyp = type(3.1)\nprint(datentyp)\n\ndatentyp = type('Hallo')\nprint(datentyp)\n\n\n\nMehr über das sogenannte Type-Casting, also das Umwandeln von einen Datentyp in\neinen anderen, erfahren wir in diesem Video.\n\nVideo “Type-Casting in Python” von Programmieren Starten","type":"content","url":"/chapter02-sec02#umwandlung-von-datentypen","position":9},{"hierarchy":{"lvl1":"2.2 Benutzereingaben","lvl2":"Zuweisungsoperator"},"type":"lvl2","url":"/chapter02-sec02#zuweisungsoperator","position":10},{"hierarchy":{"lvl1":"2.2 Benutzereingaben","lvl2":"Zuweisungsoperator"},"content":"Wichtig ist, dass das = in der Informatik eine andere Bedeutung hat als in der\nMathematik. = meint nicht das Gleichheitszeichen, sondern den sogenannten\nZuweisungsoperator. Das ist in der Programmierung ein Kommando, das eine\nSchublade befüllt oder technischer ausgedrückt, ein Objekt einer Variable\nzuweist.\n\nSehr häufig findet man Code wiex = x + 1\n\nWürden wir dies als Gleichung lesen, wie wir es aus der Mathematik gewohnt sind,\nalso x = x+1, könnten wir x auf beiden Seiten subtrahieren und erhalten\n0=1. Wir wissen, dass dies nicht wahr ist, also stimmt hier etwas nicht.\n\nIn Python sind “Gleichungen” keine mathematischen Gleichungen, sondern\nZuweisungen. “=” ist kein Gleichheitszeichen im mathematischen Sinne, sondern\neine Zuweisung. Die Zuweisung muss immer in der folgenden Weise zweistufig\ngelesen werden:\n\nBerechne den Wert auf der rechten Seite (also x+1).\n\nWeise den Wert auf der rechten Seite dem auf der linken Seite stehenden\nVariablennamen zu.\n\nWir probieren eine solche Zuweisung in der folgenden Code-Zelle aus und benutzen\nauch gleich die print()-Funktion, um den Wert der Variablen x ausgeben zu\nlassen:\n\nx = 4     \nx = x + 1\nprint(x)\n\n\n\nMini-Übung\n\nFühren Sie folgenden Code Schritt für Schritt aus und notieren Sie nach jeder\nZeile den Wert von x:x = 10\nx = x + 5\nx = x * 2\nx = x - 3\nprint(x)\n\nWas ist der finale Wert von x?\n\n# Code-Zelle\n\n\n\nLösung\n\nDer finale Wert von x ist 27.\n\nDer Zuweisungsoperator ist äußerst wichtig in der Python-Programmierung. Daher\nempfehle ich Ihnen folgendes Video.\n\nVideo “Der Zuweisungsoperator” von Programmieren Starten","type":"content","url":"/chapter02-sec02#zuweisungsoperator","position":11},{"hierarchy":{"lvl1":"2.2 Benutzereingaben","lvl2":"Zusammenfassung und Ausblick"},"type":"lvl2","url":"/chapter02-sec02#zusammenfassung-und-ausblick","position":12},{"hierarchy":{"lvl1":"2.2 Benutzereingaben","lvl2":"Zusammenfassung und Ausblick"},"content":"Das EVA-Prinzip ist das grundlegende Prinzip der Datenverarbeitung. Mit den\nPython-Funktionen input() und print() und den Datentypen Integer, Float und\nString haben wir bereits die wichtigsten Bausteine zusammen, um kleine\nPython-Programme zu schreiben.","type":"content","url":"/chapter02-sec02#zusammenfassung-und-ausblick","position":13},{"hierarchy":{"lvl1":"Übungen"},"type":"lvl1","url":"/chapter02-sec03","position":0},{"hierarchy":{"lvl1":"Übungen"},"content":"Übung 2.1\n\nBetrachten Sie die folgenden beiden Code-Zeilen:print(5 + 3)\nprint('5' + '3')\n\nSagen Sie vorher, was jeweils ausgegeben wird.\n\nFühren Sie den Code in der nächsten Code-Zelle aus und überprüfen Sie Ihre\nVorhersage.\n\nErklären Sie, warum die Ausgaben unterschiedlich sind.\n\n# Code-Zelle\n\n\n\nLösung\n\nVorhersage\n\nprint(5 + 3) gibt 8 aus\n\nprint('5' + '3') gibt 53 aus\n\nAusführung Beim Ausführen des Codes sehen Sie genau diese Ausgaben.\n\nErklärung\n\nIn der ersten Zeile werden zwei Integer (Ganzzahlen) addiert. Der\n+-Operator führt eine mathematische Addition durch: 5 + 3 = 8\n\nIn der zweiten Zeile werden zwei Strings (Zeichenketten) verkettet. Die\nAnführungszeichen machen aus den Zahlen Texte. Der +-Operator hängt bei\nStrings die Zeichenketten hintereinander: ‘5’ + ‘3’ = ‘53’\n\nWichtige Erkenntnis: Der Datentyp bestimmt, wie Operationen durchgeführt werden.\nDerselbe Operator (+) verhält sich bei Zahlen und Strings völlig\nunterschiedlich!\n\nÜbung 2.2\n\nEin Stahlträger hat eine Länge von 3.5 m und wiegt pro Meter 25.4 kg.\n\nSpeichern Sie die Länge in einer Variable laenge_m und das Gewicht pro Meter\nin einer Variable gewicht_pro_meter.\n\nBerechnen Sie das Gesamtgewicht des Trägers mit der Formel: Gesamtgewicht =\nLänge · Gewicht pro Meter.\n\nGeben Sie das Ergebnis mit print() aus.\n\n# Code-Zelle\n\n\n\nLösung# Variablen initialisieren\nlaenge_m = 3.5\ngewicht_pro_meter = 25.4\n\n# Berechnung\ngesamtgewicht_kg = laenge_m * gewicht_pro_meter\n\n# Ausgabe\nprint(gesamtgewicht_kg)\n\nAlternative Ausgabe mit Text und Einheit:print('Das Gesamtgewicht beträgt', gesamtgewicht_kg, 'kg')\n\nDas Ergebnis ist 88.9 kg.\n\nÜbung 2.3\n\nGegeben sind folgende Variablen für ein Bauteil:bauteil_typ = \"Schraube\"\nmaterial = \"Edelstahl\"\nnorm = \"DIN 933\"\ndurchmesser = \"M8\"\n\nVerketten Sie diese vier Strings mit dem +-Operator zu einem vollständigen\nSatz nach folgendem Muster: Bauteil: {Typ}, Material: {Material}, Norm: {Norm}, Durchmesser: {Durchmesser}. Die geschweiften Klammern { und }\nbrauchen Sie nicht ausgeben. Sie stehen hier nur als Platzhalter.\n\nGeben Sie den zusammengesetzten String mit print() aus.\n\nTipp: Vergessen Sie nicht die Leerzeichen und Kommas zwischen den Textteilen!\n\n# Code-Zelle\n\n\n\nLösung# gegebene Variablen\nbauteil_typ = \"Schraube\"\nmaterial = \"Edelstahl\"\nnorm = \"DIN 933\"\ndurchmesser = \"M8\"\n\n# String-Verkettung\nbeschreibung = \"Bauteil: \" + bauteil_typ + \", Material: \" + material + \", Norm: \" + norm + \", Durchmesser: \" + durchmesser\n\n# Ausgabe\nprint(beschreibung)\n\nAlternative kürzere Lösung (direkt in print()):print(\"Bauteil: \" + bauteil_typ + \", Material: \" + material + \", Norm: \" + norm + \", Durchmesser: \" + durchmesser)\n\nÜbung 2.4\n\nSchreiben Sie ein Programm, das nacheinander nach folgenden Informationen fragt:\n\nVorname\n\nStudiengang\n\nLieblingsfach\n\nDas Programm soll anschließend einen vollständigen Satz ausgeben: “Hallo\n{Vorname}, du studierst {Studiengang} und dein Lieblingsfach ist\n{Lieblingsfach}.” Die geschweiften Klammern { und } brauchen Sie nicht\nausgeben. Sie stehen hier nur als Platzhalter.\n\nHinweis: Verwenden Sie die input()-Funktion und String-Verkettung mit +.\n\n# Code-Zelle\n\n\n\nLösung# Eingabe\nvorname = input('Wie ist dein Vorname? ')\nstudiengang = input('Was studierst du? ')\nlieblingsfach = input('Was ist dein Lieblingsfach? ')\n\n# Ausgabe\nprint('Hallo ' + vorname + ', du studierst ' + studiengang + ' und dein Lieblingsfach ist ' + lieblingsfach + '.')\n\nBeispiel-Ausgabe: Wenn die Eingaben “Anna”, “Maschinenbau” und\n“Werkstofftechnik” sind, lautet die Ausgabe:Hallo Anna, du studierst Maschinenbau und dein Lieblingsfach ist Werkstofftechnik.\n\nÜbung 2.5\n\nSchreiben Sie ein Programm, das die Fläche eines rechteckigen Bauteils\nberechnet.\n\nFragen Sie nach der Länge des Bauteils in Metern.\n\nFragen Sie nach der Breite des Bauteils in Metern.\n\nBerechnen Sie die Fläche mit der Formel: Fläche = Länge · Breite.\n\nGeben Sie das Ergebnis aus: “Die Fläche beträgt {Ergebnis} m^2.”\n\nHinweis: Verwenden Sie float(), um die Eingaben in Fließkommazahlen\numzuwandeln, und str(), um die berechnete Fläche in der Ausgabe einzufügen.\n\n# Code-Zelle\n\n\n\nLösung# Eingabe\nlaenge_m = float(input('Geben Sie die Länge in Metern ein: '))\nbreite_m = float(input('Geben Sie die Breite in Metern ein: '))\n\n# Verarbeitung\nflaeche_m2 = laenge_m * breite_m\n\n# Ausgabe\nprint('Die Fläche beträgt ' + str(flaeche_m2) + ' m^2.')\n\nBeispiel-Ausgabe:\nBei Eingaben 3.5 und 2.4 lautet die Ausgabe:Die Fläche beträgt 8.4 m^2.\n\nÜbung 2.6\n\nGegeben ist folgende Liste von Variablennamen:\n\ntemperatur_celsius\n\n3messung\n\nKraft-Newton\n\nx\n\ngeschwindigkeit_m_pro_s\n\nlänge\n\nprint\n\nMeineVariable\n\na\n\nquerschnittsflaeche_m2\n\nAnalysieren Sie jeden Variablennamen und entscheiden Sie:\n\nungültig: Welche Namen sind in Python nicht erlaubt? Begründen Sie, warum.\n\nungeschickt: Welche Namen sind zwar erlaubt, aber in der Praxis schlecht\ngewählt? Begründen Sie, warum.\n\ngut: Welche Namen sind empfehlenswert?\n\nHinweis: Denken Sie an die Regeln, d.h. keine Zahlen am Anfang, keine Umlaute,\nkeine Bindestriche, keine Schlüsselwörter, aussagekräftige Namen bevorzugen.\n\nLösung\n\nVariablenname\n\nEinordnung\n\nBegründung\n\ntemperatur_celsius\n\ngut\n\naussagekräftig, snake_case, mit Einheit\n\n3messung\n\nungültig\n\nVariable beginnt mit einer Zahl; korrekt: messung3 oder messung_3\n\nKraft-Newton\n\nungültig\n\nBindestrich (Minus-Zeichen) ist nicht erlaubt; korrekt: kraft_newton\n\nx\n\nungeschickt\n\nzu kurz, nicht aussagekräftig; nur in sehr kurzen Programmen akzeptabel\n\ngeschwindigkeit_m_pro_s\n\ngut\n\nsehr aussagekräftig, snake_case, enthält Einheit\n\nlänge\n\nungültig\n\nUmlaut ist nicht erlaubt; korrekt: laenge\n\nprint\n\nungültig\n\nSchlüsselwort von Python, darf nicht als Variablenname verwendet werden\n\nMeineVariable\n\nungeschickt\n\nverwendet UpperCamelCase statt snake_case (empfohlen für Python-Variablen)\n\na\n\nungeschickt\n\nzu kurz, nicht aussagekräftig\n\nquerschnittsflaeche_m2\n\ngut\n\naussagekräftig, snake_case, mit Einheit (m2 für m²)\n\nÜbung 2.7\n\nGegeben ist folgender Code:spannung_V = 230\nspannung_V = spannung_V * 2\nspannung_V = spannung_V - 100\nspannung_V = spannung_V / 3\nprint(spannung_V)\n\nFühren Sie den Code gedanklich Schritt für Schritt aus und notieren Sie\nnach jeder Zeile den aktuellen Wert der Variable spannung_V.\n\nErstellen Sie eine Tabelle mit zwei Spalten: “nach Zeile” und “Wert von\nspannung”\n\nFühren Sie den Code anschließend in der Code-Zelle aus und überprüfen Sie\nIhre Vorhersage.\n\nHinweis: Denken Sie daran, dass der Zuweisungsoperator = in zwei Schritten\narbeitet: Erst wird die rechte Seite berechnet, dann wird das Ergebnis der\nVariable auf der linken Seite zugewiesen.\n\n# Code-Zelle\n\n\n\nLösung\n\nSchrittweise Ausführung:\n\nnach Zeile\n\nWert von spannung\n\nBerechnung\n\nspannung_V = 230\n\n230\n\nInitialisierung\n\nspannung_V = spannung_V * 2\n\n460\n\n230 * 2 = 460\n\nspannung_V = spannung_V - 100\n\n360\n\n460 - 100 = 360\n\nspannung_V = spannung_V / 3\n\n120.0\n\n360 / 3 = 120.0\n\nEndergebnis: 120.0\n\nErklärung: Der Zuweisungsoperator arbeitet immer nach dem gleichen Prinzip:\n\nBerechne den Wert auf der rechten Seite (dabei wird der alte Wert der\nVariable verwendet).\n\nWeise das Ergebnis der Variable auf der linken Seite zu (überschreibt den\nalten Wert).\n\nBeachten Sie: Das Ergebnis ist 120.0 (Float), nicht 120 (Integer), weil die\nDivision / in Python immer ein Float-Ergebnis liefert.\n\nÜbung 2.8\n\nEin Fahrzeug beschleunigt gleichmäßig. Die Geschwindigkeit nach einer bestimmten\nZeit kann mit folgender Formel berechnet werden:v = v_0 + a \\cdot t,\n\nwobei\n\nv = Endgeschwindigkeit in m/s,\n\nv_0 = Anfangsgeschwindigkeit in m/s,\n\na = Beschleunigung in m/s²,\n\nt = Zeit in s.\n\nSchreiben Sie ein vollständiges Programm, das\n\nnach der Anfangsgeschwindigkeit v_0 fragt (in m/s),\n\nnach der Beschleunigung a fragt (in m/s²),\n\nnach der Zeit t fragt (in s),\n\ndie Endgeschwindigkeit berechnet und\n\ndas Ergebnis ausgibt: “Nach {Zeit} Sekunden beträgt die Geschwindigkeit\n{Ergebnis} m/s”.\n\nWichtig: Strukturieren Sie Ihren Code mit Kommentaren nach dem EVA-Prinzip:\n\n# Eingabe\n\n# Verarbeitung\n\n# Ausgabe\n\nVerwenden Sie aussagekräftige Variablennamen!\n\n# Code-Zelle\n\n\n\nLösung# Eingabe\nanfangsgeschwindigkeit = float(input('Geben Sie die Anfangsgeschwindigkeit v0 in m/s ein: '))\nbeschleunigung = float(input('Geben Sie die Beschleunigung a in m/s² ein: '))\nzeit = float(input('Geben Sie die Zeit t in Sekunden ein: '))\n\n# Verarbeitung\nendgeschwindigkeit = anfangsgeschwindigkeit + beschleunigung * zeit\n\n# Ausgabe\nprint('Nach ' + str(zeit) + ' Sekunden beträgt die Geschwindigkeit ' + str(endgeschwindigkeit) + ' m/s.')\n\nBeispiel-Ausgabe:\nBei Eingaben v_0 = 10, a = 2.5, t = 4 lautet die Ausgabe:Nach 4.0 Sekunden beträgt die Geschwindigkeit 20.0 m/s.\n\nÜbung 2.9\n\nDer folgende Code soll eine Länge von Zoll in Zentimeter umrechnen (1 Zoll =\n2.54 cm). Allerdings enthält der Code mehrere Fehler und funktioniert nicht\nkorrekt.# Fehlerhafter Code\nzoll = input('Geben Sie die Länge in Zoll ein: ')\nzentimeter = zoll * 2.54\nprint('Das entspricht ' + zentimeter + ' cm.')\n\nIhre Aufgabe:\n\nKopieren Sie den Code in die Code-Zelle und führen Sie ihn aus. Welche\nFehlermeldung erhalten Sie?\n\nFügen Sie nach der Eingabezeile print(type(zoll)) ein, um den Datentyp zu\nüberprüfen.\n\nIdentifizieren Sie alle Fehler im Code.\n\nKorrigieren Sie den Code, sodass er korrekt funktioniert.\n\nTipp: Es gibt zwei Stellen, an denen Typkonvertierungen fehlen!\n\n# Code-Zelle für Fehleranalyse\n\n\n\n# Code-Zelle für korrigierten Code\n\n\n\nLösung\n\nFehleranalyse: Die erste Fehlermeldung beim Ausführen ist ein TypeError: can't multiply sequence by non-int of type 'float', weil versucht wird, einen\nString mit einer Fließkommazahl zu multiplizieren.\n\nDatentyp überprüfen: Mit type(zoll) stellen wir fest: <class 'str'>\n(sollte float sein).\n\nIdentifizierte Fehler:\n\nzoll = input(...): Rückgabe von input() ist String, muss in Float umgewandelt werden.\n\nprint(... + zentimeter + ...): zentimeter ist Float, muss für String-Verkettung in String umgewandelt werden.\n\nKorrigierter Code:# Eingabe\nzoll = float(input('Geben Sie die Länge in Zoll ein: '))\n\n# Verarbeitung\nzentimeter = zoll * 2.54\n\n# Ausgabe\nprint('Das entspricht ' + str(zentimeter) + ' cm.')\n\nBeispiel-Ausgabe: Bei Eingabe 10 Zoll:Das entspricht 25.4 cm.\n\nÜbung 10 (Mini-Projekt)\n\nSie sollen einen Rechner entwickeln, der für ein quaderförmiges Stahlbauteil das\nVolumen, das Gewicht und die Materialkosten berechnet.\n\nBenötigte Formeln:\n\nVolumen: V = Länge · Breite · Höhe (in m³)\n\nGewicht: m = V · ρ (in kg), wobei ρ die Dichte ist\n\nKosten: K = m · Preis (in €)\n\nIhr Programm soll\n\nnach folgenden Werten fragen:\n\nLänge des Bauteils in Metern,\n\nBreite des Bauteils in Metern,\n\nHöhe des Bauteils in Metern,\n\nDichte von Stahl in kg/m³ (typisch: 7850 kg/m³),\n\nPreis pro Kilogramm in € (typisch: 2-5 €/kg).\n\nDas Volumen, das Gewicht und die Gesamtkosten berechnen.\n\nAlle Ergebnisse übersichtlich ausgeben:\n\n“Volumen: {Wert} m^3”\n\n“Gewicht: {Wert} kg”\n\n“Materialkosten: {Wert} EUR”\n\nAnforderungen:\n\nVerwenden Sie aussagekräftige Variablennamen.\n\nStrukturieren Sie Ihren Code mit Kommentaren nach dem EVA-Prinzip.\n\nVerwenden Sie Zwischenvariablen für die Berechnungsergebnisse.\n\nAchten Sie auf korrekte Typkonvertierungen.\n\nTesten Sie Ihr Programm mit einem Beispiel: Länge = 2.0 m, Breite = 0.5 m, Höhe\n= 0.3 m, Dichte = 7850 kg/m³, Preis = 3.50 €/kg.\n\n# Code-Zelle\n\n\n\nLösung# Eingabe\nlaenge_m = float(input('Geben Sie die Länge des Bauteils in Metern ein: '))\nbreite_m = float(input('Geben Sie die Breite des Bauteils in Metern ein: '))\nhoehe_m = float(input('Geben Sie die Höhe des Bauteils in Metern ein: '))\ndichte_stahl_kg_m3 = float(input('Geben Sie die Dichte von Stahl in kg/m³ ein: '))\npreis_pro_kg = float(input('Geben Sie den Preis pro Kilogramm in € ein: '))\n\n# Verarbeitung\nvolumen_m3 = laenge_m * breite_m * hoehe_m\ngewicht_kg = volumen_m3 * dichte_stahl_kg_m3\nmaterialkosten_euro = gewicht_kg * preis_pro_kg\n\n# Ausgabe\nprint('Volumen: ' + str(volumen_m3) + ' m^3')\nprint('Gewicht: ' + str(gewicht_kg) + ' kg')\nprint('Materialkosten: ' + str(materialkosten_euro) + ' EUR')\n\nBeispiel-Ausgabe (mit den Testwerten: 2.0, 0.5, 0.3, 7850, 3.50):Volumen: 0.3 m^3\nGewicht: 2355.0 kg\nMaterialkosten: 8242.5 EUR","type":"content","url":"/chapter02-sec03","position":1},{"hierarchy":{"lvl1":"3.1 Listen"},"type":"lvl1","url":"/chapter03-sec01","position":0},{"hierarchy":{"lvl1":"3.1 Listen"},"content":"Bisher haben wir drei verschiedene Datentypen kennengelernt:\n\nInteger (ganze Zahlen),\n\nFloat (Fließkommazahlen) und\n\nString (Zeichenketten).\n\nDamit können wir einzelne Objekte der realen Welt gut abbilden. Mit einem String\nkönnen wir den Namen einer Person erfassen, mit einem Integer das Alter der\nPerson und mit einem Float die Körpergröße der Person gemessen in Meter. Was uns\naber bisher fehlt, ist die Möglichkeit, Sammlungen von Namen oder Körpergrößen\nzu verwalten. Daher werden wir uns in diesem Jupyter Notebook mit Listen\nbeschäftigen.","type":"content","url":"/chapter03-sec01","position":1},{"hierarchy":{"lvl1":"3.1 Listen","lvl2":"Lernziele"},"type":"lvl2","url":"/chapter03-sec01#lernziele","position":2},{"hierarchy":{"lvl1":"3.1 Listen","lvl2":"Lernziele"},"content":"Lernziele\n\nSie können eine Liste erzeugen.\n\nSie wissen, was der Fachbegriff Index bedeutet.\n\nSie können mit dem Index lesend und schreibend auf die Elemente einer\nListe zugreifen, beherrschen also Lesezugriff und Schreibzugriff.\n\nSie können die Anzahl der Elemente einer Liste mit len() bestimmen.\n\nSie können eine Liste manipulieren, z.B. die Liste mit der Methode\n\n.append() am Ende erweitern oder Werte mit der Methode .remove() löschen.\n\n","type":"content","url":"/chapter03-sec01#lernziele","position":3},{"hierarchy":{"lvl1":"3.1 Listen","lvl2":"Listen erzeugen"},"type":"lvl2","url":"/chapter03-sec01#listen-erzeugen","position":4},{"hierarchy":{"lvl1":"3.1 Listen","lvl2":"Listen erzeugen"},"content":"Eine Liste sammelt Objekte wie Integer, Floats oder Strings. Sie wird in Python\ndurch eckige Klammern [  ] erzeugt. Die Objekte, die in der Liste\ngespeichert werden, werden durch Komma getrennt.\n\nBetrachten wir ein Beispiel. Hier wird eine Liste mit den Elementen 1, 2, 3, 4,\n5 erzeugt und dann anschließend in der Variablen liste_beispiel gespeichert.\nMit der Funktion print() lassen wir den Inhalt der Liste ausgeben.\n\nliste_beispiel = [1, 2, 3, 4, 5]\nprint(liste_beispiel)\n\n\n\nProbieren Sie in der nächsten Mini-Übung selbst aus, wie eine Liste erzeugt\nwird.\n\nMini-Übung\n\nErzeugen Sie eine Liste für ein (fiktives) Werkzeug Ihrer Wahl mit der\nBezeichnung des Werkzeugs, dem Hersteller und dem Preis in Euro. Welche\nDatentypen brauchen Sie für diese drei Eigenschaften? Lassen Sie die Liste auch\nausgeben.\n\n# Code-Zelle\n\n\n\nLösungwerkzeug = ['Bohrmaschine', 'Bosch', 199.95]\nprint(werkzeug)\n\nDie Bezeichnung und der Hersteller werden durch Strings repräsentiert, der Preis\nals Float.\n\nIm folgenden Video können Sie sich die Erzeugung von Listen nochmal ansehen.\n\nVideo “Python Tutorial - Listen” von Programmieren starten","type":"content","url":"/chapter03-sec01#listen-erzeugen","position":5},{"hierarchy":{"lvl1":"3.1 Listen","lvl2":"Lese- und Schreibzugriff"},"type":"lvl2","url":"/chapter03-sec01#lese-und-schreibzugriff","position":6},{"hierarchy":{"lvl1":"3.1 Listen","lvl2":"Lese- und Schreibzugriff"},"content":"Jede Liste hat einen Index. Man kann sich eine Liste wie eine Straße mit einer\nSammlung von Häusern vorstellen. Um ein Haus in der Straße zu finden, hat es\neine Hausnummer. Und das ist in der Informatik der Index, also die Position\nin der Liste, an der ein Element zu finden ist. Etwas ungewohnt mag aber sein,\ndass Python mit der Null anfängt zu zählen.\n\nMit dem Index können wir nachsehen, welches Element an dieser Index-Position\ngespeichert ist. Das nennt man in der Informatik Lesezugriff. Oder wir\nkönnen das Element an einer bestimmten Index-Position gegen ein neues Element\naustauschen. Das nennt man dann Schreibzugriff.\n\nUm auf ein Element einer Liste zugreifen zu können (egal ob lesend oder\nschreibend), verwenden wir eckige Klammern und den Index. Der Lesezugriff für\ndas erste Element sieht beispielsweise so aus:\n\n# Erzeugung einer Liste für Schraubenschlüssel in einem Werkzeugkoffer\nwerkzeugkoffer = ['3 mm', '4 mm', '5 mm', '8 mm']\n\n# Welcher Schlüssel ist an Position 1 = Index 0?\nprint(werkzeugkoffer[0])\n\n\n\nIn der nächsten Mini-Übung wird der Lesezugriff genutzt, um ein Element in einer\nneuen Variable zu speichern und weiter damit arbeiten zu können.\n\nMini-Übung\n\nSpeichern Sie den 3. Schraubenschlüssel im Werkzeugkoffer in der Variablen\nschluessel ab und lassen Sie ihn anzeigen.\n\n# Hier Ihr Code\n\n\n\nLösung# Erzeugung einer Liste für Schraubenschlüssel in einem Werkzeugkoffer\nwerkzeugkoffer = ['3 mm', '4 mm', '5 mm', '8 mm']\n\n# Lesezugriff auf Schraubenschlüssel Position 3 = Index 2\nschluessel = werkzeugkoffer[2]\n\n# Anzeige\nprint(schluessel)\n\nDer Schreibzugriff erfolgt ebenfalls mit eckigen Klammern und dem Index. Wir\nmöchten den letzten Schraubenschlüssel durch einen 12er-Schraubenschlüssel\nersetzen.\n\n# Erzeugung einer Liste für Schraubenschlüssel in einem Werkzeugkoffer\nwerkzeugkoffer = ['3 mm', '4 mm', '5 mm', '8 mm']\n\n# Schreibzugriff: ersetze den Schraubenschlüssel an Position 4 = Index 3\n# durch 12 mm\nwerkzeugkoffer[3] = '12 mm'\n\n# Anzeige des Werkzeugkoffers zur Kontrolle\nprint(werkzeugkoffer)\n\n\n\nDer Zugriff auf Listen wird auch in dem folgenden Video erklärt.\n\nVideo “Python Tutorial - Zugriff auf Listen” von Programmieren starten\n\n","type":"content","url":"/chapter03-sec01#lese-und-schreibzugriff","position":7},{"hierarchy":{"lvl1":"3.1 Listen","lvl2":"Listen manipulieren"},"type":"lvl2","url":"/chapter03-sec01#listen-manipulieren","position":8},{"hierarchy":{"lvl1":"3.1 Listen","lvl2":"Listen manipulieren"},"content":"Die einfachste Art, eine Liste zu manipulieren, ist die Verkettung zweier\nListen zu einer neuen, erweiterten Liste. In dem folgenden Beispiel gibt es zwei\nunterschiedliche Werkzeugkoffer. Wir packen den Inhalt beider Listen mit dem\n+-Operator in eine gemeinsame, neue Liste, so als ob wir die\nSchraubenschlüssel aus beiden Koffern zusammenlegen würden. Die ursprünglichen\nListen bleiben unverändert.\n\n# Erzeugung zweier Listen für zwei Werkzeugkoffer\nwerkzeugkoffer_gross = ['5 mm', '8 mm', '12 mm', '20 mm', '24 mm', '27 mm', '30 mm']\nwerkzeugkoffer_klein = ['3 mm', '4 mm', '5 mm']\n\n# Erzeugung einer neuen, gemeinsamen Liste durch Addition\ngemeinsamer_koffer = werkzeugkoffer_gross + werkzeugkoffer_klein\n\n# Anzeige zur Kontrolle\nprint(gemeinsamer_koffer)\n\n\n\nBei der Verkettung werden die Elemente beider Listen hintereinander aufgelistet.\nEs wird nicht sortiert und es werden auch nicht doppelte Einträge bereinigt. Wir\nhatten sowohl in dem großen als auch im kleinen Werkzeugkoffer den\nSchraubenschlüssel der Größe 5 mm und daher ist er in dem gemeinsamen Koffer\ndoppelt vorhanden. Wenn wir ihn jetzt aus dem Koffer löschen wollen, verwenden\nwir die .remove()-Methode. Methoden werden hinter die Variable gesetzt und mit\neinem Punkt von der Variable abgetrennt.\n\n# Entfernung des Schraubenschlüssels 5 mm\ngemeinsamer_koffer.remove('5 mm')\n\n# Anzeige zur Kontrolle\nprint(gemeinsamer_koffer)\n\n\n\nDer erste Schraubenschlüssel 5 mm, der in der Liste gefunden wurde, wurde\nentfernt. Würden wir auch den anderen 5-mm-Schlüssel entfernen wollen, könnten\nwir die .remove()-Methode erneut anwenden. Darauf verzichten wir hier,\nmindestens einmal soll der 5-mm-Schraubenschlüssel im Koffer verbleiben.\nStattdessen erweitern wir jetzt die Liste um einen neuen Schraubenschlüssel 48\nmm. Dazu verwenden wir die .append()-Methode, die ebenfalls mit einem Punkt\ngetrennt an die Variable gesetzt wird.\n\n# Erweiterung um den neuen Schraubenschlüssel 48 mm\ngemeinsamer_koffer.append('48 mm')\n\n# Anzeige zur Kontrolle\nprint(gemeinsamer_koffer)\n\n\n\nBeide Methoden .append() und .remove() verändern die Liste direkt und geben\nnichts zurück.","type":"content","url":"/chapter03-sec01#listen-manipulieren","position":9},{"hierarchy":{"lvl1":"3.1 Listen","lvl2":"Wie lang ist eine Liste?"},"type":"lvl2","url":"/chapter03-sec01#wie-lang-ist-eine-liste","position":10},{"hierarchy":{"lvl1":"3.1 Listen","lvl2":"Wie lang ist eine Liste?"},"content":"Manchmal möchte man wissen, wie viele Elemente in einer Liste enthalten sind.\nDafür gibt es in Python die eingebaute Funktion len(), was die Abkürzung für\ndas englische Wort “length” ist.\n\n# Erzeugung einer Liste für Schraubenschlüssel in einem Werkzeugkoffer\nwerkzeugkoffer = ['3 mm', '4 mm', '5 mm', '8 mm']\n\nprint(len(werkzeugkoffer))\n\n\n\nIn diesem Beispiel enthält die Liste werkzeugkoffer vier Elemente\n(Schraubenschlüssel), daher gibt len(werkzeugkoffer) den Wert 4 zurück. Diese\nFunktion ist besonders nützlich, wenn man mit Listen arbeitet, deren Länge sich\nim Laufe des Programms verändert, weil die Liste erweitert wird oder Elemente\naus der Liste gelöscht werden.\n\nMini-Übung\n\nErzeugen Sie eine Liste mit Temperaturen einer Messreihe in °C. Bestimmen Sie\ndie Anzahl der Messungen mit len() und geben Sie aus: “Es wurden {Anzahl}\nMessungen durchgeführt. Die Liste der Messungen ist: {Messungen}.”.\n\nDie geschweiften Klammern { und } brauchen nicht ausgegeben werden. Sie\nsollen andeuten, dass an dieser Stelle des Satzes die richtigen Werte eingefügt\nwerden.\n\n# Code-Zelle\n\n\n\nLösung# Eingabe: Erzeugung der Liste mit den Messungen in Grad Celsius\nmessungen_celsius = [23.1, 22.9, 23.1, 23.2]\n\n# Verarbeitung: Bestimmung der Anzahl der Messungen\nanzahl = len(messungen_celsius)\n\n# Ausgabe\nprint('Es wurden', anzahl, 'Messungen durchgeführt.')\nprint('Die Liste der Messungen ist:', messungen_celsius, '.')","type":"content","url":"/chapter03-sec01#wie-lang-ist-eine-liste","position":11},{"hierarchy":{"lvl1":"3.1 Listen","lvl2":"Zusammenfassung und Ausblick"},"type":"lvl2","url":"/chapter03-sec01#zusammenfassung-und-ausblick","position":12},{"hierarchy":{"lvl1":"3.1 Listen","lvl2":"Zusammenfassung und Ausblick"},"content":"In diesem Kapitel haben wir gelernt, wie man mit Listen mehrere Werte in Python\nstrukturiert als Sammlung speichern kann. Wir wissen nun, wie Listen erstellt\nund manipuliert werden. Außerdem kennen wir mit len() eine einfache\nMöglichkeit, die Länge einer Liste zu bestimmen. Diese Konzepte bilden die\nGrundlage für viele weiterführende Themen wie Schleifen und Interaktionen, die\nin späteren Kapiteln behandelt werden.","type":"content","url":"/chapter03-sec01#zusammenfassung-und-ausblick","position":13},{"hierarchy":{"lvl1":"3.2 Liniendiagramme"},"type":"lvl1","url":"/chapter03-sec02","position":0},{"hierarchy":{"lvl1":"3.2 Liniendiagramme"},"content":"Python kann auch auf leistungsarmer Hardware laufen wie beispielsweise auf dem\nRaspberry Pi. Ein Grund für die Effizienz von Python ist, dass nicht alle\nmöglichen Datentypen, Funktionen und Methoden von Beginn an in den Speicher\ngeladen werden, sondern erst bei Bedarf. Python-Code ist in sogenannte Module\nunterteilt.\n\nIn diesem Jupyter Notebook werden wir den Modul-Mechanismus anhand des\nPlotly-Express-Moduls kennenlernen.","type":"content","url":"/chapter03-sec02","position":1},{"hierarchy":{"lvl1":"3.2 Liniendiagramme","lvl2":"Lernziele"},"type":"lvl2","url":"/chapter03-sec02#lernziele","position":2},{"hierarchy":{"lvl1":"3.2 Liniendiagramme","lvl2":"Lernziele"},"content":"Lernziele\n\nSie können ein Modul mit einem Alias importieren.\n\nSie können mit dem Befehl dir() sich den Inhalt des Moduls anzeigen\nlassen.\n\nSie können mit dem Befehl help() sich die Hilfe zu einer Funktion\nanzeigen lassen.\n\nSie können mit Plotly Express ein Liniendiagramm mit Titel und\nAchsenbeschriftung generieren.","type":"content","url":"/chapter03-sec02#lernziele","position":3},{"hierarchy":{"lvl1":"3.2 Liniendiagramme","lvl2":"Import von Modulen"},"type":"lvl2","url":"/chapter03-sec02#import-von-modulen","position":4},{"hierarchy":{"lvl1":"3.2 Liniendiagramme","lvl2":"Import von Modulen"},"content":"Module sind Python-Code, der Konstanten oder Anweisungen (Funktionen, Klassen)\nzur Verfügung stellt, die den eigentlichen Python-Kern erweitern. Module müssen\nimportiert werden, damit der Python-Interpreter diese erweiterten\nFunktionalitäten benutzen kann.\n\nEs gibt mehrere Anweisungen, ein Modul zu importieren. Wir verwenden hier den\nsogenannten Alias-Import. Ein Alias ist eine Abkürzung, in diesem Fall für\nden Namen des Moduls. Theoretisch können wir jeden beliebigen Alias verwenden,\nin der Praxis haben sich jedoch bestimmte Aliase eingebürgert. Im Fall von\nPlotly Express ist px der Standard-Alias. Um also das Modul Plotly Express\nmit dem alias px zu importieren, schreiben wir die folgende Code-Zeile:\n\nimport plotly.express as px\n\n\n\nWird die obige Anweisung ausgeführt, passiert scheinbar nichts. Tatsächlich hat\nder Python-Interpreter jedoch das Modul geladen. Die Anweisung dir(px) listet\nauf, was genau alles importiert wurde.\n\ndir(px)\n\n\n\nDie Liste der importierten Funktionalitäten ist ganz schön lang. Modulinhalte\nmit einem Unterstrich _ oder zwei Unterstrichen __ ignorieren wir in dieser\nVorlesung. Wenn wir wissen möchten, was sich hinter den einzelnen\nFunktionalitäten verbirgt, können wir die eingebaute Hilfe von Python aufrufen.\nDazu suchen wir uns einen Modulinhalt aus, über die wir mehr wissen wollen, und\nrufen dann die Funktion help() auf. Wenn wir beispielsweise mehr über\nscatter wissen wollen, lautet der Aufruf folgendermaßen:\n\nhelp(px.scatter)\n\n\n\nAlias benutzen\n\nWenn wir eine Konstante, Funktion oder Klasse aus einem Modul benutzen wollen,\ndas wir mit einem Alias importiert haben, müssen wir immer den Alias\nvoranstellen und mit einem Punkt von der Funktionalität abtrennen.\n\nOffensichtlich ist px.scatter eine Funktion (“function”), die einen\nScatterplot in 2D erstellt. Dabei ist Scatterplot die englische Bezeichnung für\nStreudiagramm.\n\nMini-Übung\n\nRufen Sie die eingebaute Hilfe für die Funktion line auf und vergleichen Sie\ndie Ausgabe mit dem Hilfetext zu scatter. Gibt es Gemeinsamkeiten in der\nStruktur der Hilfebeschreibung?\n\n# Code-Zelle\n\n\n\nLösung\n\nBei den Hilfebeschreibungen wird zuerst der Funktionsaufruf mit Argumenten\ngezeigt, dann folgt eine kurze Beschreibung, was der Zweck der Funktion ist. Als\nnächstes werden detailliert die Parameter der Funktion beschrieben und zuletzt\nwird der Rückgabewert der Funktion angezeigt. Damit folgt die Hilfe dem\nEVA-Prinzip. Die Hilfe beantwortet die Fragen:\n\nWelche Eingaben sind möglich (Argumente und Parameter der Funktion)?\n\nWas gibt die Funktion nach der Verarbeitung als Ausgabe zurück?","type":"content","url":"/chapter03-sec02#import-von-modulen","position":5},{"hierarchy":{"lvl1":"3.2 Liniendiagramme","lvl2":"Liniendiagramme"},"type":"lvl2","url":"/chapter03-sec02#liniendiagramme","position":6},{"hierarchy":{"lvl1":"3.2 Liniendiagramme","lvl2":"Liniendiagramme"},"content":"Wir bleiben bei der line()-Funktion. Die Hilfe verrät uns, dass das erste\nArgument der Funktion data_frame ist. Die Standardeinstellung lautet:\ndata_frame=None. Dabei steht None für einen fehlenden oder leeren Wert. Wir\nbrauchen also das erste Argument nicht notwendigerweise. Das zweite Argument ist\nx=None und das dritte Argument y=None. Auch diese Argumente sind optional.\nIn der Beschreibung der Parameter steht, dass x und y Listen sein können.\nProbieren wir es aus. Wir betrachten ein Auto, das von 100 km/h auf 0 km/h\nabgebremst wird. Dabei wird die Temperatur der Bremsscheibe in °C gemessen.\n\n# Zeit in Sekunden während des Bremsvorgangs\nzeit_s = [0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0]\n\n# Temperatur der Bremsscheibe in °C\ntemperatur_celsius = [80, 145, 210, 265, 305, 335, 350]\n\n# Visualisierung als Liniendiagramm\npx.line(x=zeit_s, y=temperatur_celsius)\n\n\n\n\n\nIn Jupyter Notebooks wird das Diagramm meist automatisch angezeigt. Mit\n.show() erzwingen wir die Anzeige explizit. Dazu speichern wir zunächst das\nDiagramm in einer Variablen (hier fig) und wenden dann .show() an.\n\n# Visualisierung als Liniendiagramm unabhängig vom Jupyter Notebook\nfig = px.line(x=zeit_s, y=temperatur_celsius)\nfig.show()\n\n\n\nJedes Diagramm muss Achsenbeschriftungen und einen Titel haben! Die Hilfe verrät\nuns, dass dem Parameter title ein String übergeben werden kann. Wir setzen das\nArgument auf den Titel “Bremsscheibentemperatur während der Bremsung”.\n\n# Visualisierung als Liniendiagramm mit Titel\nfig = px.line(x=zeit_s, y=temperatur_celsius,\n              title='Bremsscheibentemperatur während der Bremsung')\nfig.show()\n\n\n\nAuch verrät uns die Hilfe, dass Achsenbeschriftungen über den Parameter labels\ngesteuert werden. Dabei werden die beiden Achsen über ein sogenanntes Dictionary\nkonfiguriert. Das ist eine Datenstruktur, die wir in einem späteren Kapitel noch\nausführlich behandeln werden. Für heute genügt es zu wissen: Dictionaries werden\nmit geschweiften Klammern { } erzeugt und ordnen Schlüsseln Werte zu. Die\nSyntax ist: {‘Schlüssel’: ‘Wert’}.\n\n# Visualisierung als Liniendiagramm mit Titel und Achsenbeschriftung\nfig = px.line(x=zeit_s, y=temperatur_celsius,\n              title='Bremsscheibentemperatur während der Bremsung',\n              labels={'x': 'Zeit in Sekunden', 'y': 'Temperatur in °C'})\nfig.show()\n\n\n\nMit Titel und Achsenbeschriftung haben wir ein vollständiges Liniendiagramm\nerstellt.\n\nMini-Übung\n\nNach einer Bergabfahrt, wo das Auto häufig bremsen musste, wird es geparkt. Die\nfolgende Tabelle gibt an, wie die sich die stark erhitzte Bremsscheibe wieder\nabkühlt:\n\nZeit [min]\n\nBremsscheibentemperatur [°C]\n\n0\n\n380\n\n1\n\n310\n\n2\n\n265\n\n3\n\n230\n\n5\n\n185\n\n7\n\n155\n\n10\n\n120\n\n15\n\n85\n\nVisualisieren Sie diese Messdaten als Liniendiagramm. Setzen Sie auch einen\nTitel und eine passende Achsenbeschriftung.\n\n# Code-Zelle\n\n\n\nLösung# Zeit nach Ende der Fahrt in Minuten\nzeit_minuten = [0, 1, 2, 3, 5, 7, 10, 15]\n\n# Bremsscheibentemperatur in °C\ntemperatur_celsius = [380, 310, 265, 230, 185, 155, 120, 85]\n\n# Visualisierung als Liniendiagramm\nfig = px.line(x=zeit_minuten, y=temperatur_celsius, \n              title='Abkühlung der Bremsscheibe nach Bergabfahrt',\n              labels={'x': 'Zeit in Minuten', 'y': 'Temperatur in °C'})\nfig.show()","type":"content","url":"/chapter03-sec02#liniendiagramme","position":7},{"hierarchy":{"lvl1":"3.2 Liniendiagramme","lvl2":"Zusammenfassung und Ausblick"},"type":"lvl2","url":"/chapter03-sec02#zusammenfassung-und-ausblick","position":8},{"hierarchy":{"lvl1":"3.2 Liniendiagramme","lvl2":"Zusammenfassung und Ausblick"},"content":"Module haben dazu geführt, dass Python derzeit eine der beliebtesten\nProgrammiersprachen ist, weil es für alle möglichen denkbaren Anwendungszwecke\nModule gibt. In diesem Jupyter Notebook haben wir gelernt, Module zu importieren\nund mit der eingebauten Hilfe sich den Inhalt der Module anzusehen. Darüber\nhinaus haben wir ein erstes Modul namens Plotly Express kennengelernt, um\nMessdaten als Liniendiagramm zu visualisieren.","type":"content","url":"/chapter03-sec02#zusammenfassung-und-ausblick","position":9},{"hierarchy":{"lvl1":"Übungen"},"type":"lvl1","url":"/chapter03-sec03","position":0},{"hierarchy":{"lvl1":"Übungen"},"content":"Übung 3.1\n\nErzeugen Sie die folgenden Listen und geben Sie sie mit print() aus:\n\neine Liste mit den Schraubenschlüssel-Größen 10, 13, 17, 19, 22 (gemessen in\nmm),\n\neine Liste mit den Materialnamen “Stahl”, “Aluminium”, “Titan”, “Kupfer” und\n\neine Liste mit gemischten Datentypen für ein Bauteil: Name “Welle”, Material\n“Stahl”, Gewicht 12.5, Anzahl 3.\n\nFrage: Welche Datentypen enthält die dritte Liste?\n\n# Code-Zelle\n\n\n\nLösung# Liste 1: Schraubenschlüssel-Größen\nschraubenschluessel = [10, 13, 17, 19, 22]\nprint(schraubenschluessel)\n\n# Liste 2: Materialnamen\nmaterialien = [\"Stahl\", \"Aluminium\", \"Titan\", \"Kupfer\"]\nprint(materialien)\n\n# Liste 3: gemischte Datentypen für ein Bauteil\nbauteil = [\"Welle\", \"Stahl\", 12.5, 3]\nprint(bauteil)\n\nAntwort zur Frage: Die dritte Liste enthält vier Elemente mit folgenden Datentypen:\n\nIndex 0: String (“Welle”)\n\nIndex 1: String (“Stahl”)\n\nIndex 2: Float (12.5)\n\nIndex 3: Integer (3)\n\nÜbung 3.2\n\nBetrachten Sie folgende Liste mit Temperaturmessungen:temperaturen = [20.5, 22.3, 21.8, 23.1, 24.5]\n\nSagen Sie vorher, was die folgenden Anweisungen ausgeben:\n\nprint(temperaturen[0])\n\nprint(temperaturen[2])\n\nprint(temperaturen[4])\n\nFühren Sie den Code in der Code-Zelle aus und überprüfen Sie Ihre Vorhersage.\n\nErklären Sie: Warum gibt temperaturen[2] die dritte Temperatur aus und nicht die zweite?\n\n# Code-Zelle\n\n\n\nLösung\n\nVorhersage:\n\ntemperaturen[0] gibt 20.5 aus (erstes Element)\n\ntemperaturen[2] gibt 21.8 aus (drittes Element)\n\ntemperaturen[4] gibt 24.5 aus (fünftes Element)\n\nCode zur Überprüfung:temperaturen = [20.5, 22.3, 21.8, 23.1, 24.5]\nprint(temperaturen[0])\nprint(temperaturen[2])\nprint(temperaturen[4])\n\nErklärung: Python verwendet eine 0-basierte Indexierung. Das bedeutet:\n\nIndex 0 = 1. Element (Position 1)\n\nIndex 1 = 2. Element (Position 2)\n\nIndex 2 = 3. Element (Position 3)\n\nund so weiter...\n\nDer Index gibt also nicht die Position an, sondern zählt ab 0. Daher liefert\ntemperaturen[2] das dritte Element, nicht das zweite!\n\nÜbung 3.3\n\nIn einem Werkzeugkoffer wurde ein Schraubenschlüssel falsch einsortiert. Gegeben\nist folgende Liste:werkzeugkoffer = ['8 mm', '10 mm', '17 mm', '19 mm', '24 mm']\n\nDie Größe an Position 3 (Index 2) ist falsch. Es sollte ein\n13-mm-Schraubenschlüssel sein.\n\nKorrigieren Sie die Liste, indem Sie das falsche Element durch ‘13 mm’\nersetzen.\n\nGeben Sie die korrigierte Liste aus, um das Ergebnis zu überprüfen.\n\n# Code-Zelle\n\n\n\nLösung# gegeben: Liste mit Fehler\nwerkzeugkoffer = ['8 mm', '10 mm', '17 mm', '19 mm', '24 mm']\n\n# Korrektur: ersetze Element an Position 3 (Index 2)\nwerkzeugkoffer[2] = '13 mm'\n\n# Ausgabe zur Kontrolle\nprint(werkzeugkoffer)\n\nAusgabe:['8 mm', '10 mm', '13 mm', '19 mm', '24 mm']\n\nErklärung: Mit dem Schreibzugriff werkzeugkoffer[2] = '13 mm' wird das Element\nan Index 2 (Position 3) durch den neuen Wert ersetzt. Der alte Wert ‘17 mm’ wird\nüberschrieben.\n\nÜbung 3.4\n\nBei einem Prüfstand wurden Kraftmessungen (in Newton) durchgeführt. Die\nMesswerte sind in folgender Liste gespeichert:kraftmessungen_newton = [145.2, 148.7, 146.3, 149.1, 147.8, 148.2]\n\nBestimmen Sie die Anzahl der Messungen mit der Funktion len() und speichern\nSie das Ergebnis in der Variable anzahl_messungen.\n\nGeben Sie einen Satz aus: “Es wurden {Anzahl} Kraftmessungen durchgeführt.”\n\nDie geschweiften Klammern { und } brauchen Sie nicht ausgeben. Sie stehen\nhier nur als Platzhalter.\n\n# Code-Zelle\n\n\n\nLösung# gegeben: Liste der Kraftmessungen\nkraftmessungen_newton = [145.2, 148.7, 146.3, 149.1, 147.8, 148.2]\n\n# Anzahl bestimmen\nanzahl_messungen = len(kraftmessungen_newton)\n\n# Ausgabe\nprint('Es wurden', anzahl_messungen, 'Kraftmessungen durchgeführt.')\n\nAusgabe:Es wurden 6 Kraftmessungen durchgeführt.\n\nÜbung 3.5\n\nSie möchten eine Liste mit Drehzahl-Messungen (gemessen in Umdrehungen pro\nMinute) erstellen und diese schrittweise erweitern.\n\nBeginnen Sie mit einer leeren Liste drehzahlen_umin = [].\n\nFügen Sie nacheinander folgende Drehzahl-Werte mit der Methode .append()\nhinzu: 500, 1000, 1500, 2000, 2500 (alle in U/min).\n\nGeben Sie nach jedem Hinzufügen die aktuelle Liste aus, um die Veränderung zu\nsehen.\n\nBestimmen Sie am Ende mit len() die Anzahl der Messungen.\n\n# Code-Zelle\n\n\n\nLösung# Start mit leerer Liste\ndrehzahlen_umin = []\n\n# Schrittweises Hinzufügen mit .append()\ndrehzahlen_umin.append(500)\nprint(drehzahlen_umin)\n\ndrehzahlen_umin.append(1000)\nprint(drehzahlen_umin)\n\ndrehzahlen_umin.append(1500)\nprint(drehzahlen_umin)\n\ndrehzahlen_umin.append(2000)\nprint(drehzahlen_umin)\n\ndrehzahlen_umin.append(2500)\nprint(drehzahlen_umin)\n\n# Anzahl bestimmen\nanzahl = len(drehzahlen_umin)\nprint('Anzahl der Messungen:', anzahl)\n\nAusgabe:[500]\n[500, 1000]\n[500, 1000, 1500]\n[500, 1000, 1500, 2000]\n[500, 1000, 1500, 2000, 2500]\nAnzahl der Messungen: 5\n\nErklärung: Die Methode .append() fügt ein Element am Ende der Liste hinzu.\nNach jedem Aufruf wird die Liste um ein Element länger. Dies ist besonders\nnützlich, wenn Daten schrittweise erfasst werden (z.B. bei mehreren Messungen\nnacheinander).\n\nÜbung 3.6\n\nIn einem Lager wurden Bauteile gezählt. Die Liste enthält jedoch einen doppelten\nEintrag, der korrigiert werden muss:bauteile = ['Schraube M8', 'Mutter M8', 'Scheibe', 'Schraube M8', 'Unterlegscheibe']\n\nDie Schraube M8 wurde versehentlich doppelt erfasst.\n\nEntfernen Sie die erste vorkommende ‘Schraube M8’.\n\nGeben Sie die bereinigte Liste aus.\n\nEntfernen Sie auch die zweite ‘Schraube M8’.\n\nVersuchen Sie anschließend nochmal ‘Schraube M8’ zu entfernen. Was passiert?\nWarum?\n\n# Code-Zelle\n\n\n\nLösung# gegeben: Liste mit doppeltem Eintrag\nbauteile = ['Schraube M8', 'Mutter M8', 'Scheibe', 'Schraube M8', 'Unterlegscheibe']\n\n# Entfernung des ersten Vorkommens\nbauteile.remove('Schraube M8')\nprint(bauteile)\n\n# Nochmaliges Entfernen\nbauteile.remove('Schraube M8')\nprint(bauteile)\n\n# Versuch, ein drittes Mal zu entfernen: erzeugt Fehler!\n# bauteile.remove('Schraube M8')  # ValueError!\n\nAusgabe:['Mutter M8', 'Scheibe', 'Schraube M8', 'Unterlegscheibe']\n['Mutter M8', 'Scheibe', 'Unterlegscheibe']\n\nErklärung:\n\n.remove() entfernt immer nur das erste Vorkommen eines Elements.\n\nNach dem ersten .remove() ist noch eine ‘Schraube M8’ in der Liste (an\nPosition 4).\n\nNach dem zweiten .remove() gibt es keine ‘Schraube M8’ mehr.\n\nEin dritter Versuch würde einen ValueError erzeugen, weil das Element nicht\nmehr in der Liste existiert.\n\nÜbung 3.7\n\nSie planen eine WG-Party und erstellen gemeinsam mit Ihren Mitbewohnern eine\nEinkaufsliste. Gegeben sind zwei separate Listen:einkauf_alice = ['Chips', 'Cola', 'Salsa', 'Nachos']\neinkauf_bob = ['Pizza', 'Bier', 'Eis']\n\nBearbeiten Sie folgende Schritte:\n\nVerketten Sie beide Listen zu einer gemeinsamen Liste einkaufsliste.\n\nAlice fällt ein, dass noch Käse fehlt. Fügen Sie ‘Käse’ mit .append()\nhinzu.\n\nBob ist spontan zum Veganer geworden und möchte keine Pizza mehr. Entfernen\nSie ‘Pizza’ mit .remove().\n\nAlice möchte doch lieber Wasser statt Cola. Ersetzen Sie ‘Cola’ an der\nentsprechenden Position durch ‘Wasser’.\n\nBestimmen Sie mit len() die finale Anzahl der Artikel.\n\nGeben Sie die finale Einkaufsliste und die Anzahl aus.\n\n# Code-Zelle\n\n\n\nLösung# gegeben: zwei separate Einkaufslisten\neinkauf_alice = ['Chips', 'Cola', 'Salsa', 'Nachos']\neinkauf_bob = ['Pizza', 'Bier', 'Eis']\n\n# 1. Verkettung\neinkaufsliste = einkauf_alice + einkauf_bob\nprint('Nach Verkettung:', einkaufsliste)\n\n# 2. Käse hinzufügen\neinkaufsliste.append('Käse')\nprint('Nach append:', einkaufsliste)\n\n# 3. Pizza entfernen\neinkaufsliste.remove('Pizza')\nprint('Nach remove:', einkaufsliste)\n\n# 4. Cola durch Wasser ersetzen (Cola ist an Index 1)\neinkaufsliste[1] = 'Wasser'\nprint('Nach Schreibzugriff:', einkaufsliste)\n\n# 5. Anzahl bestimmen\nanzahl = len(einkaufsliste)\n\n# 6. Finale Ausgabe\nprint('Finale Einkaufsliste:', einkaufsliste)\nprint('Anzahl der Artikel:', anzahl)\n\nAusgabe:Nach Verkettung: ['Chips', 'Cola', 'Salsa', 'Nachos', 'Pizza', 'Bier', 'Eis']\nNach append: ['Chips', 'Cola', 'Salsa', 'Nachos', 'Pizza', 'Bier', 'Eis', 'Käse']\nNach remove: ['Chips', 'Cola', 'Salsa', 'Nachos', 'Bier', 'Eis', 'Käse']\nNach Schreibzugriff: ['Chips', 'Wasser', 'Salsa', 'Nachos', 'Bier', 'Eis', 'Käse']\nFinale Einkaufsliste: ['Chips', 'Wasser', 'Salsa', 'Nachos', 'Bier', 'Eis', 'Käse']\nAnzahl der Artikel: 7\n\nÜbung 3.8\n\nBei einem Belastungstest wurde die Dehnung eines Materials bei verschiedenen\nKräften gemessen. Die Messdaten sind:kraft_N = [0, 100, 200, 300, 400, 500]\ndehnung_mm = [0, 0.15, 0.31, 0.47, 0.65, 0.83]\n\nErstellen Sie ein Liniendiagramm, das diese Messdaten visualisiert. Setzen Sie\nauch einen Titel und passende Achsenbeschriftungen.\n\n# Code-Zelle\n\n\n\nLösung# Import\nimport plotly.express as px\n\n# Messdaten\nkraft_N = [0, 100, 200, 300, 400, 500]\ndehnung_mm = [0, 0.15, 0.31, 0.47, 0.65, 0.83]\n\n# Liniendiagramm erstellen\nfig = px.line(x=kraft_N, y=dehnung_mm,\n              title='Kraft-Dehnungs-Diagramm',\n              labels={'x': 'Kraft in N', 'y': 'Dehnung in mm'})\n\n# Anzeige\nfig.show()\n\nÜbung 3.9\n\nSchreiben Sie ein Programm, das Temperaturmessungen erfasst und visualisiert.\n\nDas Programm soll:\n\nEine leere Liste temperaturen_celsius erstellen.\n\nViermal nacheinander nach einer Temperatur in °C fragen.\n\nJeden eingegebenen Wert in eine Fließkommazahl umwandeln und zur Liste\nhinzufügen.\n\nNach allen Eingaben die Anzahl der Messungen bestimmen und ausgeben: “Es\nwurden {Anzahl} Temperaturen erfasst.”\n\nEin Liniendiagramm erstellen mit:\n\nx-Achse: Messnummern [1, 2, 3, 4]\n\ny-Achse: die erfassten Temperaturen\n\nTitel: “Temperaturverlauf”\n\nAchsenbeschriftungen: x = “Messung Nr.”, y = “Temperatur in °C”\n\nStrukturieren Sie Ihren Code mit EVA-Kommentaren!\n\n# Code-Zelle\n\n\n\nLösung# Import\nimport plotly.express as px\n\n# Eingabe\ntemperaturen_celsius = []\n\ntemp1 = float(input('Geben Sie die 1. Temperatur in °C ein: '))\ntemperaturen_celsius.append(temp1)\n\ntemp2 = float(input('Geben Sie die 2. Temperatur in °C ein: '))\ntemperaturen_celsius.append(temp2)\n\ntemp3 = float(input('Geben Sie die 3. Temperatur in °C ein: '))\ntemperaturen_celsius.append(temp3)\n\ntemp4 = float(input('Geben Sie die 4. Temperatur in °C ein: '))\ntemperaturen_celsius.append(temp4)\n\n# Verarbeitung\nanzahl = len(temperaturen_celsius)\nmessnummern = [1, 2, 3, 4]\n\n# Ausgabe\nprint('Es wurden', anzahl, 'Temperaturen erfasst.')\n\nfig = px.line(x=messnummern, y=temperaturen_celsius,\n              title='Temperaturverlauf',\n              labels={'x': 'Messung Nr.', 'y': 'Temperatur in °C'})\nfig.show()\n\nBeispiel-Ausgabe (bei Eingaben 22.5, 23.1, 23.8, 24.2):Es wurden 4 Temperaturen erfasst.\n\nAnschließend wird das Liniendiagramm angezeigt.\n\nÜbung 3.10 (Mini-Projekt)\n\nSie arbeiten in der Qualitätskontrolle und prüfen gefertigte Wellen. Der\nSoll-Durchmesser beträgt 50.0 mm. Bei 5 Bauteilen wurden folgende\nIst-Durchmesser gemessen:ist_durchmesser_mm = [50.2, 49.8, 73.5, 50.1, 49.9]\n\nEin Messwert ist offensichtlich falsch (Ausreißer durch Messfehler).\n\nDas Programm soll folgende Aufgaben erfüllen:\n\nFehleranalyse:\n\nGeben Sie die Liste aus: “Gemessene Durchmesser: {Liste}”\n\nIdentifizieren Sie den unrealistischen Wert (Ausreißer).\n\nDatenbereinigung:\n\nEntfernen Sie den Ausreißer mit .remove().\n\nGeben Sie aus: “Bereinigte Durchmesser: {Liste}”\n\nAbweichungsberechnung:\n\nDefinieren Sie soll_durchmesser_mm = 50.0\n\nErstellen Sie eine leere Liste abweichungen_mm = []\n\nBerechnen Sie für jeden bereinigten Wert die Abweichung: ist - soll\n\nFügen Sie jede Abweichung mit .append() zur Liste hinzu.\n\nHinweis: Sie benötigen 4 Berechnungen mit Index [0], [1], [2], [3]\n\nAuswertung:\n\nBestimmen Sie die Anzahl der gültigen Messungen mit len()\n\nGeben Sie aus: “Anzahl gültiger Messungen: {Anzahl}”\n\nGeben Sie die Abweichungen aus: “Abweichungen vom Soll: {Liste} mm”\n\nVisualisierung:\n\nErstellen Sie ein Liniendiagramm mit Plotly Express\n\nx-Achse: Bauteilnummern [1, 2, 3, 4]\n\ny-Achse: Abweichungen in mm\n\nTitel: “Maßabweichungen der Wellen”\n\nAchsenbeschriftungen: x = “Bauteil Nr.”, y = “Abweichung in mm”\n\nAnforderungen:\n\nStrukturieren Sie mit EVA-Kommentaren (Eingabe, Verarbeitung, Ausgabe)\n\nVerwenden Sie aussagekräftige Variablennamen\n\n# Code-Zelle\n\n\n\nLösung# Import\nimport plotly.express as px\n\n# Eingabe\nist_durchmesser_mm = [50.2, 49.8, 73.5, 50.1, 49.9]\nsoll_durchmesser_mm = 50.0\n\n# Ausgabe der Rohdaten\nprint('Gemessene Durchmesser:', ist_durchmesser_mm)\n\n# Verarbeitung: Datenbereinigung\n# Der Ausreißer 73.5 ist offensichtlich unrealistisch.\nist_durchmesser_mm.remove(73.5)\nprint('Bereinigte Durchmesser:', ist_durchmesser_mm)\n\n# Verarbeitung: Abweichungsberechnung\nabweichungen_mm = []\n\nabweichung_1 = ist_durchmesser_mm[0] - soll_durchmesser_mm\nabweichungen_mm.append(abweichung_1)\n\nabweichung_2 = ist_durchmesser_mm[1] - soll_durchmesser_mm\nabweichungen_mm.append(abweichung_2)\n\nabweichung_3 = ist_durchmesser_mm[2] - soll_durchmesser_mm\nabweichungen_mm.append(abweichung_3)\n\nabweichung_4 = ist_durchmesser_mm[3] - soll_durchmesser_mm\nabweichungen_mm.append(abweichung_4)\n\n# Auswertung\nanzahl = len(ist_durchmesser_mm)\nprint('Anzahl gültiger Messungen:', anzahl)\nprint('Abweichungen vom Soll:', abweichungen_mm, 'mm')\n\n# Ausgabe: Visualisierung\nbauteilnummern = [1, 2, 3, 4]\n\nfig = px.line(x=bauteilnummern, y=abweichungen_mm,\n              title='Maßabweichungen der Wellen',\n              labels={'x': 'Bauteil Nr.', 'y': 'Abweichung in mm'})\nfig.show()\n\nBeispiel-Ausgabe:Gemessene Durchmesser: [50.2, 49.8, 73.5, 50.1, 49.9]\nBereinigte Durchmesser: [50.2, 49.8, 50.1, 49.9]\nAnzahl gültiger Messungen: 4\nAbweichungen vom Soll: [0.2, -0.2, 0.1, -0.1] mm\n\nAnschließend wird das Liniendiagramm mit den Abweichungen angezeigt.\n\nErklärung: Dieses Mini-Projekt zeigt einen typischen Qualitätskontroll-Workflow:\n\nMessdaten werden analysiert (visuelle Prüfung)\n\nAusreißer werden identifiziert und entfernt (remove)\n\nAbweichungen vom Sollwert werden berechnet (Subtraktion + append)\n\nErgebnisse werden dokumentiert (len, print)\n\nAbweichungen werden visualisiert (Lineplot)\n\nPositive Abweichungen bedeuten: Bauteil ist zu dick Negative Abweichungen\nbedeuten: Bauteil ist zu dünn\n\nDas Diagramm zeigt, dass alle bereinigten Bauteile innerhalb ±0.2 mm vom\nSollwert liegen.","type":"content","url":"/chapter03-sec03","position":1},{"hierarchy":{"lvl1":"4.1 Wahrheitswerte und Vergleiche"},"type":"lvl1","url":"/chapter04-sec01","position":0},{"hierarchy":{"lvl1":"4.1 Wahrheitswerte und Vergleiche"},"content":"Viele Möglichkeiten unserer Gesellschaft stehen nur Volljährigen offen und sind\ndamit an eine Altersangabe gebunden. Wenn jetzt ein Computersystem vorab prüfen\nsoll, ob Volljährigkeit vorliegt oder nicht, dann brauchen wir einen einfachen\nVergleich. Daher beschäftigen wir uns in diesem Kapitel mit Vergleichen und dem\nDatentyp Bool.","type":"content","url":"/chapter04-sec01","position":1},{"hierarchy":{"lvl1":"4.1 Wahrheitswerte und Vergleiche","lvl2":"Lernziele"},"type":"lvl2","url":"/chapter04-sec01#lernziele","position":2},{"hierarchy":{"lvl1":"4.1 Wahrheitswerte und Vergleiche","lvl2":"Lernziele"},"content":"Lernziele\n\nSie kennen den Datentyp Bool mit seinen beiden Werten True und\nFalse.\n\nSie kennen die wichtigsten Vergleichsoperatoren für Zahlen und\nStrings.\n\nSie können mit in überprüfen, ob ein Teilstring in einem String\nenthalten ist.","type":"content","url":"/chapter04-sec01#lernziele","position":3},{"hierarchy":{"lvl1":"4.1 Wahrheitswerte und Vergleiche","lvl2":"Der Datentyp Bool"},"type":"lvl2","url":"/chapter04-sec01#der-datentyp-bool","position":4},{"hierarchy":{"lvl1":"4.1 Wahrheitswerte und Vergleiche","lvl2":"Der Datentyp Bool"},"content":"Zurück zu dem Beispiel mit der Überprüfung der Volljährigkeit. Angenommen, wir\nspeichern das Alter des Benutzers oder der Benutzerin in der Variable alter.\nDamit wäre ein simples Beispiel für einen einfachen Vergleich der mathematische\nAusdruck alter < 18. Der Wert der Variablen alter wird also mit der Zahl 18\nverglichen. Dieser Vergleich ist entweder wahr (True) oder falsch\n(False). Oder anders formuliert, diese Bedingung ist entweder erfüllt oder\nnicht erfüllt.\n\nUm den Wahrheitswert einer Bedingung zu speichern, hat Python einen eigenen\nDatentyp, den sogenannten booleschen Datentyp. Nach dem englischen Wort wird\ndieser Datentyp in der Informatik üblicherweise Bool oder Boolean\ngenannt. Das Besondere an diesem Datentyp ist, dass eine Variable dieses\nDatentyps nur zwei verschiedene Werte annehmen kann, nämlich\n\nTrue: Wahrheitswert ist wahr oder\n\nFalse: Wahrheitswert ist falsch.\n\nAber wie kann man dann überprüfen, welcher Datentyp in einer Variablen\ngespeichert ist? Dazu gibt es die Funktion type().\n\nvariable = False\ntype(variable)\n\n\n\nIst in einer Variablen ein Objekt vom Datentyp Bool gespeichert, gibt die\nFunktion type() den Wert bool aus.","type":"content","url":"/chapter04-sec01#der-datentyp-bool","position":5},{"hierarchy":{"lvl1":"4.1 Wahrheitswerte und Vergleiche","lvl2":"Vergleiche mit Zahlen"},"type":"lvl2","url":"/chapter04-sec01#vergleiche-mit-zahlen","position":6},{"hierarchy":{"lvl1":"4.1 Wahrheitswerte und Vergleiche","lvl2":"Vergleiche mit Zahlen"},"content":"Nachdem wir jetzt den Datentyp Bool kennengelernt haben, mit dem Python das\nErgebnis eines Vergleichs speichert, kommen wir zu dem Vergleich selbst.\n\nZunächst beschäftigen wir uns mit mathematischen Vergleichen. In der Mathematik\nist ein Vergleich ein Ausdruck mit zwei Argumenten und einem Vergleichsoperator\nin der Mitte. Die beiden Argumente können auch unterschiedliche Datentypen\nhaben, dann muss der Vergleichsoperator aber sinnvoll für diese Datentypen\ndefiniert sein. Zum Beispiel darf man einen Integer mit einem Float vergleichen\n\n3 < 17.2\n\naber\n\n3 < 'vier'\n\nführt in Python zu einem Fehler (TypeError), da Zahlen und Strings nicht\nmiteinander verglichen werden können.\n\nEs gibt die folgenden Vergleichsoperatoren in Python:\n\n<   kleiner\n\n<=  kleiner oder gleich\n\n>   größer\n\n>=  größer oder gleich\n\n==  gleich\n\n!= ungleich\n\nMit Python können wir leicht den Wahrheitsgehalt von Vergleichen überprüfen. Wir\nsetzen eine Variable auf den Wert 7:\n\nx = 7\n\n\n\nJetzt probieren wir in den nachfolgenden Code-Zellen verschiedene\nVergleichsoperatoren aus.\n\nIst x kleiner als 7?\n\nprint(x < 7)  # Ausgabe: False\n\n\n\nIst x kleiner oder gleich 7?\n\nprint(x <= 7)  # Ausgabe: True\n\n\n\nIst x größer als 10?\n\nprint(x > 10)  # Ausgabe: False\n\n\n\nIst x größer oder gleich 10?\n\nprint(x >= 10)  # Ausgabe: False\n\n\n\nIst x gleich 7?\n\nprint(x == 7)  # Ausgabe: True\n\n\n\nIst x ungleich 7?\n\nprint(x != 7)  # Ausgabe: False\n\n\n\nMini-Übung\n\nWählen Sie sich eine Zahl. Testen Sie anschließend:\n\nIst Ihre Zahl kleiner gleich 5?\n\nIst Ihre Zahl genau 17?\n\nIst Ihre Zahl nicht gleich 17?\n\nIst Ihre Zahl positiv?\n\nIst Ihre Zahl kleiner als -17.7?\n\n# Code-Zelle\n\n\n\nLösung# Eingabe: Wahl meiner Zahl\nx = 33\n\n# kleiner gleich 5?\nprint(x <= 5)\n\n# genau gleich 17?\nprint(x == 17)\n\n# nicht gleich 17?\nprint(x != 17)\n\n# positiv?\nprint(x > 0)\n\n# kleiner als -17.7?\nprint(x < -17.7)\n\nVideo “Vergleiche in Python” von Programmieren Starten","type":"content","url":"/chapter04-sec01#vergleiche-mit-zahlen","position":7},{"hierarchy":{"lvl1":"4.1 Wahrheitswerte und Vergleiche","lvl2":"Vergleiche mit Strings"},"type":"lvl2","url":"/chapter04-sec01#vergleiche-mit-strings","position":8},{"hierarchy":{"lvl1":"4.1 Wahrheitswerte und Vergleiche","lvl2":"Vergleiche mit Strings"},"content":"Als Nächstes beschäftigen wir uns mit dem Vergleich von Strings. Um zu prüfen,\nob zwei Strings in Python gleich sind, verwenden wir den Gleichheitsoperator\n==. Dieser gibt True zurück, wenn die Strings exakt übereinstimmen, und\nandernfalls False.\n\nprint('Hallo' == 'Welt')   # False\nprint('Hallo' == 'Hallo')  # True\nprint('Hallo' == 'hallo')  # False\n\n\n\nDie ersten beiden Beispiele sind offensichtlich, jedoch das dritte Beispiel\nverdient mehr Aufmerksamkeit. Python unterscheidet strikt zwischen Groß- und\nKleinschreibung. Daher sind die beiden Strings 'Hallo' und 'hallo' nicht\ngleich.\n\nUm zu überprüfen, ob ein String in einem anderen enthalten ist, können wir den\nOperator in verwenden. Der Operator in gibt True zurück, wenn der\nerste Teilstring in dem zweiten String enthalten ist, und ansonsten False.\n\nprint('Welt' in 'Hallo Welt')    # True\nprint('Python' in 'Hallo Welt')  # False\n\n\n\nHinweis: Python unterscheidet bei String-Vergleichen zwischen Groß- und\nKleinschreibung. Suchen wir beispielsweise nach dem String 'welt', ergibt der\nVergleich mit 'Welt' den Wert False, da die Schreibweise nicht\nübereinstimmt.\n\nWir können auch andere Vergleichsoperationen wie <, >, <=, >= mit Strings\nverwenden. Diese Operationen vergleichen die Strings lexikografisch, also\nZeichen für Zeichen von links nach rechts. Sobald ein Zeichen in den beiden\nStrings unterschiedlich ist, entscheidet dieses Zeichen über das Gesamtergebnis.\n\nprint('Apfel' < 'Banane')    # True, da 'A' im Alphabet vor 'B' steht\nprint('Apfel' < 'Aprikose')  # True, da 'f' vor 'r' kommt\nprint('Apfel' < 'apfel')     # True, da Großbuchstaben vor Kleinbuchstaben kommen\n\n\n\nErklärung:\n\n“Apfel” ist kleiner als “Banane”, weil der erste Buchstabe “A” im Alphabet vor\n“B” steht.\n\n“Apfel” ist kleiner als “Aprikose”, da beim ersten Unterschied (dritter\nBuchstabe) “f” vor “r” kommt.\n\nGroßbuchstaben werden in Python als kleiner eingestuft als Kleinbuchstaben.\nDaher ist “A” kleiner als “a”, und der letzte Vergleich ergibt True.\n\nMini-Übung\n\nGegeben sind die folgenden Strings:material1 = \"Stahl\"\nmaterial2 = \"Aluminium\"\nmaterial3 = \"Stahllegierung\"\nmaterial4 = \"aluminium\"\n\nÜberprüfen Sie folgende Vergleiche und überlegen Sie zunächst selbst, bevor Sie\nden Code ausführen:\n\nIst material1 lexikografisch größer als material2?\n\nEnthält material3 den String material1?\n\nSind material2 und material4 identisch?\n\nÜberprüfen Sie mit dem in-Operator, ob die Zeichenfolge “leg” in\nmaterial3 vorkommt.\n\nIst material4 lexikografisch kleiner als material1?\n\n# Code-Zelle\n\n\n\nLösungmaterial1 = \"Stahl\"\nmaterial2 = \"Aluminium\"\nmaterial3 = \"Stahllegierung\"\nmaterial4 = \"aluminium\"\n\n# 1. Ist material1 lexikografisch größer als material2?\nprint(material1 > material2)  # True, da 'S' im Alphabet nach 'A' kommt\n\n# 2. Enthält material3 den String material1?\nprint(material1 in material3)  # True, da \"Stahl\" in \"Stahllegierung\" enthalten ist\n\n# 3. Sind material2 und material4 identisch?\nprint(material2 == material4)  # False, da Groß-/Kleinschreibung unterschiedlich ist\n\n# 4. Überprüfen Sie mit dem in-Operator, ob die Zeichenfolge \"leg\" in material3 vorkommt.\nprint(\"leg\" in material3)     # True, da \"leg\" in \"Stahllegierung\" enthalten ist\n\n# 5. Ist material4 lexikografisch kleiner als material1?\nprint(material4 < material1)  # False, da \"a\" (Kleinbuchstabe) als größer gilt als \"S\" (Großbuchstabe)","type":"content","url":"/chapter04-sec01#vergleiche-mit-strings","position":9},{"hierarchy":{"lvl1":"4.1 Wahrheitswerte und Vergleiche","lvl2":"Zusammenfassung und Ausblick"},"type":"lvl2","url":"/chapter04-sec01#zusammenfassung-und-ausblick","position":10},{"hierarchy":{"lvl1":"4.1 Wahrheitswerte und Vergleiche","lvl2":"Zusammenfassung und Ausblick"},"content":"In diesem Kapitel haben wir den booleschen Datentyp Bool mit seinen Werten\nTrue und False kennengelernt. Wir haben Vergleichsoperatoren (<, >, ==, !=,\n<=, >=) für Zahlen und Strings untersucht und gesehen, wie String-Vergleiche auf\nlexikografischer Ordnung basieren. Außerdem haben wir den in-Operator zur\nÜberprüfung von Teilstrings kennengelernt. Im nächsten Kapitel werden wir\nVergleiche einsetzen, um abhängig vom Ergebnis des Vergleichs Entscheidungen zu\ntreffen.","type":"content","url":"/chapter04-sec01#zusammenfassung-und-ausblick","position":11},{"hierarchy":{"lvl1":"4.2 Einfache Verzweigung"},"type":"lvl1","url":"/chapter04-sec02","position":0},{"hierarchy":{"lvl1":"4.2 Einfache Verzweigung"},"content":"Im letzten Kapitel haben wir gelernt, wie ein Vergleich in Python durchgeführt\nwird und mit welchem Datentyp das Ergebnis eines solchen Vergleichs gespeichert\nwird. In diesem Kapitel geht es nun darum, dass ein Python-Programm auf das\nErgebnis eines Vergleichs reagiert, indem Code-Abschnitte nur dann ausgeführt\nwerden, wenn eine Bedingung erfüllt ist.","type":"content","url":"/chapter04-sec02","position":1},{"hierarchy":{"lvl1":"4.2 Einfache Verzweigung","lvl2":"Lernziele"},"type":"lvl2","url":"/chapter04-sec02#lernziele","position":2},{"hierarchy":{"lvl1":"4.2 Einfache Verzweigung","lvl2":"Lernziele"},"content":"Lernziele\n\nSie können mit if eine Programmverzweigung implementieren.\n\nSie können mit einer if-Verzweigung Titel und Achsenbeschriftungen eines\nLiniendiagramms sprachabhängig setzen.","type":"content","url":"/chapter04-sec02#lernziele","position":3},{"hierarchy":{"lvl1":"4.2 Einfache Verzweigung","lvl2":"Syntax der if-Verzweigung"},"type":"lvl2","url":"/chapter04-sec02#syntax-der-if-verzweigung","position":4},{"hierarchy":{"lvl1":"4.2 Einfache Verzweigung","lvl2":"Syntax der if-Verzweigung"},"content":"Verzweigungen werden beim Programmieren eingesetzt, um eine Entscheidung zu\ntreffen. Abhängig vom Ausgang der Entscheidung wird Code ausgeführt. Wir\ngreifen das Beispiel der Bremsscheibe wieder auf. Ein Messsensor im Auto misst\ndie Temperatur. Sobald die kritische Temperatur von 300 °C überschritten wird,\nsoll eine Warnung im Cockpit ausgegeben werden. Mit Python wird das\nfolgendermaßen realisiert (ändern Sie die Temperatur auch auf Werte kleiner 300\n°C und beobachten Sie, was ausgegeben wird):\n\n# Konfiguration\nKRITISCHE_TEMPERATUR_C = 300\n\n# Eingabe der Temperatur Bremsscheibe in Grad Celsius\ntemperatur_C = 318\n\n# Entscheidung\nif temperatur_C > KRITISCHE_TEMPERATUR_C:\n    print('Warnung: die kritische Temperatur der Bremsscheibe ist überschritten.')\n    print('Bitte halten Sie an.')\nprint('Fahren Sie immer mit angepasster Geschwindigkeit!')\n\n\n\nZuerst definieren wir eine Konstante für die kritische Temperatur von 300 °C. In\nder Python-Community ist es üblich, für Konstanten durchgängig GROSSBUCHSTABEN\nzu verwenden. Die Großschreibung signalisiert: nicht ändern! Dann simulieren\nwir den Messsensor, indem wir manuell die aktuelle Temperatur (hier 318 °C) der\nVariablen temperatur_C zuweisen. Jetzt kommt der interessante Code. Wenn die\naktuelle Temperatur temperatur_C größer als die kritische Temperatur ist,\ndann soll die Warnung ausgegeben werden. Dazu verwenden wir in Python das\nSchlüsselwort if zusammen mit der Bedingung temperatur_C > KRITISCHE_TEMPERATUR_C, die von einem Doppelpunkt : abgeschlossen wird. Die\nAusgabe der Warnung mit print() wird durch vier Leerzeichen eingerückt. Code\nohne Einrückung wird immer ausgeführt, so wie hier der Hinweis, immer mit\nangepasster Geschwindigkeit zu fahren.\n\nFassen wir zusammen. Bei einer Programmverzweigung wird Code abhängig von einer\nBedingung ausgeführt. Im einfachsten Fall liegt ein sogenannter if-Block\nvor. Die Syntax lautet wie folgt:if bedingung:\n    anweisung1  # gehört zum if-Block\n    anweisung2  # gehört zum if-Block\n    ...\n    anweisungN  # gehört zum if-Block\nanweisung3      # gehört NICHT zum if-Block, wird immer ausgeführt\n\nIst die Bedingung erfüllt, also True, so wird der eingerückte Anweisungsblock\nausgeführt. Ist die Bedingung nicht erfüllt, wird dieser übersprungen. Damit\nist gemeint, dass der Python-Interpreter nach dem Ende des if-Blocks\nweitermacht, falls die Bedingung nicht erfüllt ist (= False).\n\nPython erkennt das Ende eines if-Blocks an der Einrückung. Alle Anweisungen, die\nmit der gleichen Einrückung nach dem Doppelpunkt folgen, gehören zum if-Block.\nSobald eine Zeile mit geringerer Einrückung (oder ohne Einrückung) erscheint,\nerkennt Python, dass der if-Block abgeschlossen ist. Diese Anweisungen werden\ndann unabhängig vom Ergebnis der if-Bedingung ausgeführt.\n\nMini-Übung\n\nSchreiben Sie ein Skript, das einen Benutzer oder eine Benutzerin nach der\nhöchsten gemessenen Temperatur der Bremsscheibe fragt. Wenn die Temperatur\ngrößer als 350 ˚C ist, soll ausgegeben werden: “Bitte lassen Sie eine Inspektion\nder Bremse in einer Werkstatt durchführen.”\n\n# Code-Zelle\n\n\n\nLösung# Eingabe der Höchsttemperatur Bremsscheibe in Grad Celsius\ntemperatur = float(input('Welche Temperatur hatte die Bremsscheibe maximal (in Grad Celsius)? '))\n\n# Verarbeitung und Ausgabe\nif temperatur > 350:\n    print('Bitte lassen Sie eine Inspektion der Bremse in einer Werkstatt durchführen.')\n\nVideo “if-Anweisung” von Programmieren Starten","type":"content","url":"/chapter04-sec02#syntax-der-if-verzweigung","position":5},{"hierarchy":{"lvl1":"4.2 Einfache Verzweigung","lvl2":"Anwendung der if-Verzweigung bei Liniendiagrammen"},"type":"lvl2","url":"/chapter04-sec02#anwendung-der-if-verzweigung-bei-liniendiagrammen","position":6},{"hierarchy":{"lvl1":"4.2 Einfache Verzweigung","lvl2":"Anwendung der if-Verzweigung bei Liniendiagrammen"},"content":"Zum Abschluss des Kapitels wenden wir die if-Verzweigung zur Gestaltung eines\nLiniendiagramms an. Zunächst erstellen wir zu (künstlichen) Messwerten der\nBremsscheiben-Temperatur ein Liniendiagramm mit Plotly Express.\n\nimport plotly.express as px\n\n# Zeit in Sekunden während des Bremsvorgangs\nzeit_s = [0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0]\n\n# Temperatur der Bremsscheibe in °C\ntemperatur_celsius = [80, 145, 210, 265, 305, 335, 350]\n\n# Visualisierung als Liniendiagramm\nfig = px.line(x=zeit_s, y=temperatur_celsius,\n              title='Bremsscheibentemperatur während der Bremsung',\n              labels={'x': 'Zeit in Sekunden', 'y': 'Temperatur in °C'})\nfig.show()\n\n\n\n\n\nMini-Übung\n\nIn internationalen Ingenieurteams müssen Diagramme oft in mehreren Sprachen\nvorliegen. Erweitern Sie das Liniendiagramm der Bremsscheibentemperatur um einen\nSprach-Umschalter: Der Benutzer oder die Benutzerin soll beim Programmstart\nwählen können, ob Titel und Achsenbeschriftungen auf Deutsch oder Englisch\nangezeigt werden. Deutsch soll die Voreinstellung sein.\n\n# Code-Zelle\n\n\n\nLösung# Import wird hier der Vollständigkeit halber wiederholt\nimport plotly.express as px\n\n# Zeit in Sekunden während des Bremsvorgangs\nzeit_s = [0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0]\n\n# Temperatur der Bremsscheibe in °C\ntemperatur_celsius = [80, 145, 210, 265, 305, 335, 350]\n\n# Voreinstellung: deutsche Texte\ntitel = 'Bremsscheibentemperatur während der Bremsung'\nbeschriftung_x = 'Zeit in Sekunden'\nbeschriftung_y = 'Temperatur in °C'\n\n# Sprachauswahl\nsprache = input('Bitte wählen Sie die Sprache (DE/EN): ')\n\n# Englische Texte, wenn EN gewählt wurde\nif sprache == 'EN':\n    titel = 'Brake disc temperature during braking'\n    beschriftung_x = 'Time in seconds'\n    beschriftung_y = 'Temperature in °C'\n\n# Visualisierung\nfig = px.line(x=zeit_s, y=temperatur_celsius,\n              title=titel,\n              labels={'x': beschriftung_x, 'y': beschriftung_y})\nfig.show()","type":"content","url":"/chapter04-sec02#anwendung-der-if-verzweigung-bei-liniendiagrammen","position":7},{"hierarchy":{"lvl1":"4.2 Einfache Verzweigung","lvl2":"Zusammenfassung und Ausblick"},"type":"lvl2","url":"/chapter04-sec02#zusammenfassung-und-ausblick","position":8},{"hierarchy":{"lvl1":"4.2 Einfache Verzweigung","lvl2":"Zusammenfassung und Ausblick"},"content":"Mit den Inhalten dieses Kapitels können wir Entscheidungen treffen. Abhängig von\ndem Ergebnis eines Vergleichs werden Teile des Codes ausgeführt oder\nübersprungen. Ein Anwendungsbeispiel haben wir bei der Gestaltung der\nSpracheinstellung des Liniendiagramms gesehen. In späteren Kapiteln werden wir\nauch mehrfache Verzweigungen behandeln.","type":"content","url":"/chapter04-sec02#zusammenfassung-und-ausblick","position":9},{"hierarchy":{"lvl1":"Übungen"},"type":"lvl1","url":"/chapter04-sec03","position":0},{"hierarchy":{"lvl1":"Übungen"},"content":"Übung 4.1 (✩)\n\nGegeben ist folgende Variable:x = 15\n\nSagen Sie vorher, welches Ergebnis die folgenden Vergleiche liefern (True oder\nFalse), und notieren Sie Ihre Antwort. Führen Sie anschließend den Code aus\nund überprüfen Sie Ihre Vorhersage.\n\nx >= 10\n\nx != 15\n\nx > 15\n\nx < 20\n\nx == 15\n\nx <= 15\n\n# Code-Zelle\n\n\n\nLösungx = 15\n\nprint(x >= 10)  # True,  da 15 größer oder gleich 10 ist\nprint(x != 15)  # False, da 15 gleich 15 ist, also nicht ungleich\nprint(x > 15)   # False, da 15 nicht größer als 15 ist\nprint(x < 20)   # True,  da 15 kleiner als 20 ist\nprint(x == 15)  # True,  da 15 gleich 15 ist\nprint(x <= 15)  # True,  da 15 kleiner oder gleich 15 ist\n\nAusgabe:True\nFalse\nFalse\nTrue\nTrue\nTrue\n\nÜbung 4.2 (✩✩)\n\nGegeben sind folgende Variablen:stadt1 = \"Ludwigshafen\"\nstadt2 = \"ludwigshafen\"\nstadt3 = \"Mannheim\"\nstadt4 = \"mannheim\"\n\nSagen Sie vorher, welches Ergebnis die folgenden Vergleiche liefern (True oder\nFalse), und notieren Sie Ihre Antwort. Führen Sie anschließend den Code aus\nund überprüfen Sie Ihre Vorhersage.\n\nstadt1 == stadt2\n\nstadt1 != stadt2\n\nstadt1 < stadt3\n\nstadt4 < stadt3\n\n\"hafen\" in stadt1\n\n\"mannheim\" == stadt3\n\n# Code-Zelle\n\n\n\nLösungstadt1 = \"Ludwigshafen\"\nstadt2 = \"ludwigshafen\"\nstadt3 = \"Mannheim\"\nstadt4 = \"mannheim\"\n\nprint(stadt1 == stadt2)     # False, da Python Groß-/Kleinschreibung unterscheidet\nprint(stadt1 != stadt2)     # True,  da \"Ludwigshafen\" und \"ludwigshafen\" nicht identisch sind\nprint(stadt1 < stadt3)      # True,  da \"L\" vor \"M\" kommt\nprint(stadt4 < stadt3)      # False, da Kleinbuchstaben als größer gelten als Großbuchstaben\nprint(\"hafen\" in stadt1)    # True,  da \"hafen\" in \"Ludwigshafen\" enthalten ist\nprint(\"mannheim\" == stadt3) # False, da Groß-/Kleinschreibung unterschiedlich ist\n\nAusgabe:False\nTrue\nTrue\nFalse\nTrue\nFalse\n\nÜbung 4.3 (✩)\n\nIn einer Lehrveranstaltung gilt: Wer mindestens 50 Punkte erreicht, hat die\nPrüfung bestanden.\n\nSchreiben Sie ein Skript, das nach der erreichten Punktzahl fragt. Wenn die\nPunktzahl mindestens 50 beträgt, soll ausgegeben werden: “Bestanden! Herzlichen\nGlückwunsch.”\n\nStrukturieren Sie Ihren Code mit EVA-Kommentaren.\n\n# Code-Zelle\n\n\n\nLösung# Eingabe\npunkte = float(input('Wie viele Punkte haben Sie erreicht? '))\n\n# Verarbeitung und Ausgabe\nif punkte >= 50:\n    print('Bestanden! Herzlichen Glückwunsch.')\n\nÜbung 4.4 (✩)\n\nAn einem Prüfstand wird der Luftdruck in einem Behälter gemessen. Der maximale\nBetriebsdruck beträgt 12.0 bar. Wird dieser Wert überschritten, muss ein\nSicherheitsventil geöffnet werden.\n\nSchreiben Sie ein Skript, das nach dem gemessenen Druck in bar fragt. Wenn der\nDruck den maximalen Betriebsdruck überschreitet, soll ausgegeben werden:\n“Warnung: Maximaldruck überschritten. Sicherheitsventil öffnen.”\n\nStrukturieren Sie Ihren Code mit EVA-Kommentaren.\n\n# Code-Zelle\n\n\n\nLösung# Eingabe\ndruck_bar = float(input('Welchen Druck hat der Behälter aktuell (in bar)? '))\n\n# Verarbeitung und Ausgabe\nif druck_bar > 12.0:\n    print('Warnung: Maximaldruck überschritten. Sicherheitsventil öffnen.')\n\nÜbung 4.5 (✩✩)\n\nAn einem internationalen Flughafen werden Passagiere in ihrer Landessprache\nbegrüßt. Schreiben Sie ein Skript, das nach dem Kürzel der gewünschten Sprache\nfragt. Geben Sie dann die passende Begrüßung aus:\n\nWenn \"DE\" eingegeben wird: “Willkommen!”\n\nWenn \"EN\" eingegeben wird: “Welcome!”\n\nWenn \"FR\" eingegeben wird: “Bienvenue!”\n\nStrukturieren Sie Ihren Code mit EVA-Kommentaren.\n\n# Code-Zelle\n\n\n\nLösung# Eingabe\nsprache = input('Bitte geben Sie das Sprachkürzel ein (DE/EN/FR): ')\n\n# Verarbeitung und Ausgabe\nif sprache == 'DE':\n    print('Willkommen!')\nif sprache == 'EN':\n    print('Welcome!')\nif sprache == 'FR':\n    print('Bienvenue!')\n\nÜbung 4.6 (✩✩✩)\n\nBei der Überwachung einer Produktionsanlage wird die Betriebstemperatur in drei\nBereiche eingeteilt:\n\nUnter 60 °C: Normalbetrieb\n\nAb 60 °C: erhöhte Betriebstemperatur\n\nAb 80 °C: kritischer Bereich\n\nSchreiben Sie ein Skript, das nach der aktuellen Betriebstemperatur fragt und\nfür jeden zutreffenden Bereich eine passende Meldung ausgibt. Strukturieren Sie\nIhren Code mit EVA-Kommentaren.\n\nTesten Sie Ihr Skript anschließend mit folgenden Temperaturen und notieren Sie\njeweils, welche Meldungen ausgegeben werden:\n\n45 °C\n\n70 °C\n\n95 °C\n\nWas beobachten Sie bei 95 °C? Warum werden bei dieser Temperatur zwei Meldungen\nausgegeben?\n\n# Code-Zelle\n\n\n\nLösung# Eingabe\ntemperatur_C = float(input('Wie hoch ist die aktuelle Betriebstemperatur (in °C)? '))\n\n# Verarbeitung und Ausgabe\nif temperatur_C < 60:\n    print('Normalbetrieb.')\nif temperatur_C >= 60:\n    print('erhöhte Betriebstemperatur.')\nif temperatur_C >= 80:\n    print('kritischer Bereich.')\n\nTestergebnisse:\n\n45 °C → Normalbetrieb.\n\n70 °C → erhöhte Betriebstemperatur.\n\n95 °C → erhöhte Betriebstemperatur. und kritischer Bereich.\n\nErklärung: Bei 95 °C sind zwei Bedingungen gleichzeitig wahr, sowohl\ntemperatur_C >= 60 als auch temperatur_C >= 80. Da alle drei if-Blöcke\nunabhängig voneinander ausgewertet werden, gibt Python beide Meldungen aus.\nDas ist kein Fehler, sondern das erwartete Verhalten bei mehreren unabhängigen\nif-Blöcken.\n\nIn einem späteren Kapitel werden wir if-elif-else kennenlernen. Damit lässt\nsich sicherstellen, dass immer genau eine Meldung ausgegeben wird. Sobald eine\nBedingung erfüllt ist, werden die übrigen nicht mehr geprüft.\n\nÜbung 4.7 (✩✩)\n\nGegeben ist folgende Liste mit den aktuellen Tabellenplätzen 1 bis 5\nder 1. Fußball-Bundesliga:tabelle = [\"Bayern München\", \"Borussia Dortmund\", \"TSG Hoffenheim\", \"VfB Stuttgart\", \"RB Leipzig\"]\n\nSchreiben Sie ein Skript, das den Benutzer oder die Benutzerin fragt: “Welcher\nVerein steht aktuell auf Platz 3?” Wenn die Antwort korrekt ist, soll ausgegeben\nwerden: “Richtig!”\n\nGeben Sie anschließend aus, welcher Verein tatsächlich auf dem eingegebenen\nTabellenplatz steht.\n\nStrukturieren Sie Ihren Code mit EVA-Kommentaren.\n\n# Code-Zelle\n\n\n\nLösung# Eingabe\ntabelle = [\"Bayern München\", \"Borussia Dortmund\", \"TSG Hoffenheim\", \"VfB Stuttgart\", \"RB Leipzig\"]\nantwort = input('Welcher Verein steht aktuell auf Platz 3? ')\n\n# Verarbeitung und Ausgabe\nif antwort == tabelle[2]:\n    print('Richtig!')\nprint('Auf Platz 3 steht:', tabelle[2])\n\nFür den Zugriff auf den 3. Platz in der Tabelle benutzen wir Index 2.\n\nÜbung 4.8 (✩✩✩)\n\nGegeben sind folgende Messwerte der Bremsscheibentemperatur:zeit_s = [0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0]\ntemperatur_celsius = [80, 145, 210, 265, 305, 335, 350]\n\nBerechnen Sie den Durchschnitt der Temperaturwerte, indem Sie die einzelnen\nListenelemente über ihren Index addieren und durch die Anzahl der Messungen\nteilen.\n\nErstellen Sie anschließend ein Liniendiagramm mit Titel und\nAchsenbeschriftungen. Wenn der Durchschnitt über 200 °C liegt, soll der Titel\n“Bremsscheibentemperatur während der Bremsung (erhöhte Durchschnittstemperatur)”\nlauten. Andernfalls bleibt der Titel “Bremsscheibentemperatur während der\nBremsung”.\n\nTesten Sie Ihr Skript mit zwei Fällen:\n\nTestfall 1: Die oben angegebenen Temperaturwerte.\n\nTestfall 2: Ersetzen Sie die Temperaturwerte durch [60, 80, 100, 120, 140, 160, 180] und beobachten Sie, wie sich der Titel ändert.\n\nStrukturieren Sie Ihren Code mit EVA-Kommentaren.\n\n# Code-Zelle\n\n\n\nLösung\n\nTestfall 1: Durchschnitt über 200 °C:import plotly.express as px\n\n# Eingabe\nzeit_s = [0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0]\ntemperatur_celsius = [80, 145, 210, 265, 305, 335, 350]\n\ndurchschnitt_C = (temperatur_celsius[0] + temperatur_celsius[1] +\n                  temperatur_celsius[2] + temperatur_celsius[3] +\n                  temperatur_celsius[4] + temperatur_celsius[5] +\n                  temperatur_celsius[6]) / 7\nSCHWELLENWERT_C = 200\n\n# Verarbeitung\ntitel = 'Bremsscheibentemperatur während der Bremsung'\n\nif durchschnitt_C > SCHWELLENWERT_C:\n    titel = 'Bremsscheibentemperatur während der Bremsung (erhöhte Durchschnittstemperatur)'\n\nfig = px.line(x=zeit_s, y=temperatur_celsius,\n              title=titel,\n              labels={'x': 'Zeit in Sekunden', 'y': 'Temperatur in °C'})\n\n# Ausgabe\nfig.show()\n\nTestfall 2: Durchschnitt unter 200 °C (Temperaturwerte ersetzen):temperatur_celsius = [60, 80, 100, 120, 140, 160, 180]\n\nBei diesen Werten ergibt der Durchschnitt (60+80+100+120+140+160+180)/7 ≈ 120 °C\nund der Titel bleibt unverändert.\n\nÜbung 4.9  (✩✩✩)\n\nBei einem internationalen Ingenieurbüro werden Messdaten der Bremsscheibe in\nverschiedenen Einheiten dokumentiert. Gegeben sind folgende Messwerte:zeit_s = [0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0]\ntemperatur_celsius = [80, 145, 210, 265, 305, 335, 350]\n\nErweitern Sie das Liniendiagramm der Bremsscheibentemperatur um einen Einheiten-Umschalter: Der Benutzer oder die Benutzerin soll beim Programmstart wählen können, ob die Temperatur in Grad Celsius (°C) oder Fahrenheit (°F) angezeigt werden soll. Grad Celsius soll die Voreinstellung sein.\n\nDie Umrechnung von Celsius in Fahrenheit lautet: °F = °C * 9/5 + 32\n\nBerechnen Sie bei Wahl von Fahrenheit jeden Temperaturwert über seinen Index um und speichern Sie die Ergebnisse in einer neuen Liste temperatur_fahrenheit. Passen Sie auch die Achsenbeschriftung entsprechend an.\n\nStrukturieren Sie Ihren Code mit EVA-Kommentaren.\n\n# Code-Zelle\n\n\n\nLösungimport plotly.express as px\n\n# Eingabe\nzeit_s = [0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0]\ntemperatur_celsius = [80, 145, 210, 265, 305, 335, 350]\n\neinheit = input('Bitte wählen Sie die Einheit (C/F): ')\n\n# Verarbeitung\ny_werte = temperatur_celsius\nbeschriftung_y = 'Temperatur in °C'\n\nif einheit == 'F':\n    temperatur_fahrenheit = [temperatur_celsius[0] * 9/5 + 32,\n                             temperatur_celsius[1] * 9/5 + 32,\n                             temperatur_celsius[2] * 9/5 + 32,\n                             temperatur_celsius[3] * 9/5 + 32,\n                             temperatur_celsius[4] * 9/5 + 32,\n                             temperatur_celsius[5] * 9/5 + 32,\n                             temperatur_celsius[6] * 9/5 + 32]\n    y_werte = temperatur_fahrenheit\n    beschriftung_y = 'Temperatur in °F'\n\n# Ausgabe\nfig = px.line(x=zeit_s, y=y_werte,\n              title='Bremsscheibentemperatur während der Bremsung',\n              labels={'x': 'Zeit in Sekunden', 'y': beschriftung_y})\nfig.show()\n\nHinweis: Die Umrechnung der sieben Temperaturwerte über den Index ist korrekt,\naber repetitiv. Im nächsten Kapitel werden wir for-Schleifen kennenlernen, mit\ndenen sich diese Berechnung eleganter und kürzer formulieren lässt, ohne jeden\nIndex einzeln aufzuschreiben.\n\nÜbung 4.10 (Mini-Projekt)\n\nSie beobachten den Kursverlauf einer fiktiven Aktie über eine Handelswoche. Die\nKurse in Euro sind:tage = [\"Mo\", \"Di\", \"Mi\", \"Do\", \"Fr\"]\nkurse_euro = [120.0, 124.5, 118.3, 115.7, 122.8]\n\nSie haben die Aktie zu einem Einstiegspreis von 120.00 Euro gekauft. Schreiben\nSie ein Programm, das folgende Fragen beantwortet:\n\nAn welchen Handelstagen lag der Kurs unter dem Einstiegspreis?\n\nHaben Sie am Freitag einen Gewinn oder Verlust gemacht, und wie hoch ist\ndieser?\n\nVisualisieren Sie den Kursverlauf abschließend als Liniendiagramm.\n\nOptionale Erweiterung: Färben Sie die Linie rot, wenn der Freitagskurs unter\ndem Einstiegspreis liegt, und grün, wenn er darüber liegt. Verwenden Sie dazu\nfig.update_traces(line_color='red') bzw. fig.update_traces(line_color='green').\n\nAnforderungen:\n\nStrukturieren Sie mit EVA-Kommentaren.\n\nVerwenden Sie aussagekräftige Variablennamen.\n\nDefinieren Sie den Einstiegspreis als Konstante.\n\n# Code-Zelle\n\n\n\nLösungimport plotly.express as px\n\n# Eingabe\ntage = [\"Mo\", \"Di\", \"Mi\", \"Do\", \"Fr\"]\nkurse_euro = [120.0, 124.5, 118.3, 115.7, 122.8]\nEINSTIEGSPREIS_EURO = 120.0\n\n# Verarbeitung: Verlustanalyse\nif kurse_euro[0] < EINSTIEGSPREIS_EURO:\n    print('Mo: Kurs unter Einstiegspreis! Kurs:', kurse_euro[0], 'Euro')\nif kurse_euro[1] < EINSTIEGSPREIS_EURO:\n    print('Di: Kurs unter Einstiegspreis! Kurs:', kurse_euro[1], 'Euro')\nif kurse_euro[2] < EINSTIEGSPREIS_EURO:\n    print('Mi: Kurs unter Einstiegspreis! Kurs:', kurse_euro[2], 'Euro')\nif kurse_euro[3] < EINSTIEGSPREIS_EURO:\n    print('Do: Kurs unter Einstiegspreis! Kurs:', kurse_euro[3], 'Euro')\nif kurse_euro[4] < EINSTIEGSPREIS_EURO:\n    print('Fr: Kurs unter Einstiegspreis! Kurs:', kurse_euro[4], 'Euro')\n\n# Verarbeitung: Gewinn/Verlust am Freitag\ndifferenz_euro = kurse_euro[4] - EINSTIEGSPREIS_EURO\n\nif differenz_euro > 0:\n    print('Aktueller Gewinn am Freitag:', differenz_euro, 'Euro')\nif differenz_euro < 0:\n    print('Aktueller Verlust am Freitag:', differenz_euro, 'Euro')\n\n# Ausgabe: Visualisierung\nfig = px.line(x=tage, y=kurse_euro,\n              title='Kursverlauf der Aktie',\n              labels={'x': 'Handelstag', 'y': 'Kurs in Euro'})\n\n# Optionale Erweiterung: Linienfarbe\nif differenz_euro > 0:\n    fig.update_traces(line_color='green')\nif differenz_euro < 0:\n    fig.update_traces(line_color='red')\n\nfig.show()\n\nHinweis: Die wiederholte Prüfung jedes Tageskurses über den Index ist korrekt,\naber repetitiv. Im nächsten Kapitel werden wir for-Schleifen kennenlernen,\nmit denen sich diese Analyse elegant in wenigen Zeilen formulieren lässt.","type":"content","url":"/chapter04-sec03","position":1},{"hierarchy":{"lvl1":"5.1 for-Schleifen"},"type":"lvl1","url":"/chapter05-sec01","position":0},{"hierarchy":{"lvl1":"5.1 for-Schleifen"},"content":"In der Praxis kommt es oft vor, dass wir von vornherein wissen, wie oft wir eine\nHandlung wiederholen wollen. Beispielsweise soll in einem Verein darüber\nabgestimmt werden, ob Anna oder Bob zukünftig die Kasse verwalten soll. Alle\nVereinsmitglieder schreiben einen der beiden Namen auf einen Zettel und werfen\nihn in die Wahlurne. Jetzt beginnt die Wiederholung. Charlie greift in die Urne,\nzieht einen Zettel heraus, liest den Namen vor und macht dann entweder bei Anna\noder bei Bob einen Strich auf dem Flipboard. Solange Zettel in der Urne sind,\nwird diese Prozedur wiederholt. In Python verwenden wir dafür die sogenannte\nfor-Schleife.","type":"content","url":"/chapter05-sec01","position":1},{"hierarchy":{"lvl1":"5.1 for-Schleifen","lvl2":"Lernziele"},"type":"lvl2","url":"/chapter05-sec01#lernziele","position":2},{"hierarchy":{"lvl1":"5.1 for-Schleifen","lvl2":"Lernziele"},"content":"Lernziele\n\nSie können eine for-Schleife mit Liste programmieren.\n\nSie wissen, wie die Fachbegriffe der einzelnen Bestandteile der Schleife\nlauten:\n\nKopfzeile, wird mit Doppelpunkt : abgeschlossen\n\nSchlüsselwörter for und in\n\nSchleifenvariable\n\nSie können Zahlenlisten mit der range()-Funktion erzeugen und diese mit\nder for-Schleife kombinieren.","type":"content","url":"/chapter05-sec01#lernziele","position":3},{"hierarchy":{"lvl1":"5.1 for-Schleifen","lvl2":"for-Schleifen mit Liste"},"type":"lvl2","url":"/chapter05-sec01#for-schleifen-mit-liste","position":4},{"hierarchy":{"lvl1":"5.1 for-Schleifen","lvl2":"for-Schleifen mit Liste"},"content":"Erkunden wir den folgenden Python-Code, der das Vorlesen der Wahlzettel\nnachbildet:\n\nfor zettel in [\"Bob\", \"Anna\", \"Anna\", \"Bob\", \"Anna\", \"Bob\", \"Anna\"]:\n    print(zettel)\n\n\n\nNacheinander wird die Variable zettel auf die Werte in der Liste [\"Bob\", \"Anna\", \"Anna\", \"Bob\", \"Anna\", \"Bob\", \"Anna\"] gesetzt und per print()\nausgegeben. Dieses Programmierkonstrukt nennt man eine for-Schleife.\n\nEine for-Schleife beginnt mit dem Schlüsselwort for. Danach kommt der Name\nder sogenannten Schleifenvariable, in diesem Fall also zettel. Als\nnächstes folgt wieder ein Schlüsselwort, nämlich in und zuletzt eine Liste.\nDiese Zeile nennt man Kopfzeile.\n\nPython muss wissen, welche Kommandos für jeden Schleifendurchgang ausgeführt\nwerden sollen. Daher wird die Kopfzeile der Schleife mit einem Doppelpunkt :\nbeendet. Danach werden alle Kommandos aufgelistet, die ausgeführt werden sollen.\nDamit Python weiß, wann es wieder mit dem Code außerhalb der Schleife\nweitergehen soll, müssen wir dem Python-Interpreter das Ende der Schleife\nsignalisieren. In vielen Programmiersprachen wird das mit dem Schlüsselwort\nend gemacht oder es werden Klammern gesetzt. In Python wird stattdessen mit\nEinrückung gearbeitet. Alle Zeilen mit Anweisungen, die eingerückt sind,\nwerden in der Schleife wiederholt.\n\nIn dem obigen Beispiel heißt die Schleifenvariable zettel. Sie nimmt beim 1.\nSchleifendurchgang den Wert \"Bob\" an. Dann werden die Anweisungen im\nSchleifeninneren ausgeführt, also die print()-Funktion für zettel = \"Bob\"\nangewendet und “Bob” ausgegeben. Dann wird die Schleife ein 2. Mal durchlaufen.\nDiesmal nimmt die Schleifenvariable zettel den Wert \"Anna\" an und die\nprint()-Funktion gibt “Anna” aus. Das geht so weiter bis zum 7.\nSchleifendurchgang, wo die Schleifenvariable den Wert zettel = \"Anna\" annimmt\nund “Anna” auf dem Bildschirm angezeigt wird. Da dies das letzte Element der\nListe war, macht der Python-Interpreter mit dem Code außerhalb der Schleife\nweiter. Bei unserem kurzen Beispiel ist aber schon das Ende des Programmes\nerreicht. Zusammengefasst, werden nacheinander die Elemente der Liste \"Bob\", \"Anna\", \"Anna\", \"Bob\", \"Anna\", \"Bob\", \"Anna\" auf dem Bildschirm ausgegeben.\n\nAllgemein hat die for-Schleife mit Liste folgende Syntax (= Grammatik einer\nProgrammiersprache):for element in liste:\n    anweisungen","type":"content","url":"/chapter05-sec01#for-schleifen-mit-liste","position":5},{"hierarchy":{"lvl1":"5.1 for-Schleifen","lvl2":"Anwendungsbeispiel der for-Schleife"},"type":"lvl2","url":"/chapter05-sec01#anwendungsbeispiel-der-for-schleife","position":6},{"hierarchy":{"lvl1":"5.1 for-Schleifen","lvl2":"Anwendungsbeispiel der for-Schleife"},"content":"Meistens geht es nicht darum, nur etwas einzeln anzuzeigen, sondern die Elemente\nder Menge zu verarbeiten. Im nächsten Beispiel soll gezählt werden, wie viele\nStimmen für Anna und Bob abgegeben wurden.\n\nWir initialisieren zwei Variablen anzahl_anna und anzahl_bob mit dem Wert\n0. Mit einer for-Schleife gehen wir jeden Zettel durch. Steht auf dem Zettel\nAnna, erhöhen wir den Wert der Variablen anzahl_anna um 1. Steht auf dem\nZettel Bob, erhöhen wir den Wert der Variablen anzahl_bob um 1. Beide\nErgebnisse geben wir am Ende aus.\n\nanzahl_anna = 0\nanzahl_bob = 0\n\nfor zettel in [\"Bob\", \"Anna\", \"Anna\", \"Bob\", \"Anna\", \"Bob\", \"Anna\"]:\n    # Anna steht auf Zettel\n    if zettel == \"Anna\":\n        anzahl_anna = anzahl_anna + 1\n    # Bob steht auf Zettel\n    if zettel == \"Bob\":\n        anzahl_bob = anzahl_bob + 1\n\nprint('Stimmen für Anna: ', anzahl_anna)\nprint('Stimmen für Bob: ', anzahl_bob)\n\n\n\nMini-Übung\n\nBei der Wahl ist ein Fehler passiert: Ein Vereinsmitglied hat versehentlich\n„Charlie\" auf seinen Zettel geschrieben. Die Urne enthält jetzt folgende Zettel:\n\n[\"Bob\", \"Anna\", \"Anna\", \"Charlie\", \"Anna\", \"Bob\", \"Anna\"]\n\nFühren Sie den obigen Code mit der neuen Liste aus. Was gibt das Programm aus?\nErklären Sie das Ergebnis.\n\nErgänzen Sie den Code so, dass auch die Anzahl ungültiger Stimmen berechnet\nund ausgegeben wird. Hinweis: Zählen Sie die Gesamtzahl der Zettel in der\nSchleife mit.\n\n# Code-Zelle\n\n\n\nLösung\n\nDas Programm gibt aus:Stimmen für Anna:  4\nStimmen für Bob:   2\n\nDie Gesamtzahl der Stimmen beträgt nur 6, obwohl 7 Zettel in der Urne lagen.\nDer Zettel mit „Charlie\" wird von keiner der beiden if-Bedingungen erfasst\nund daher stillschweigend ignoriert.anzahl_anna = 0\nanzahl_bob = 0\nanzahl_gesamt = 0\n\nfor zettel in [\"Bob\", \"Anna\", \"Anna\", \"Charlie\", \"Anna\", \"Bob\", \"Anna\"]:\n    anzahl_gesamt = anzahl_gesamt + 1\n    if zettel == \"Anna\":\n        anzahl_anna = anzahl_anna + 1\n    if zettel == \"Bob\":\n        anzahl_bob = anzahl_bob + 1\n\nanzahl_ungueltig = anzahl_gesamt - anzahl_anna - anzahl_bob\n\nprint('Stimmen für Anna: ', anzahl_anna)\nprint('Stimmen für Bob: ', anzahl_bob)\nprint('Ungültige Stimmen: ', anzahl_ungueltig)\n\nVideo “for-Schleife” von Programmieren Starten","type":"content","url":"/chapter05-sec01#anwendungsbeispiel-der-for-schleife","position":7},{"hierarchy":{"lvl1":"5.1 for-Schleifen","lvl2":"for-Schleifen mit range()"},"type":"lvl2","url":"/chapter05-sec01#for-schleifen-mit-range","position":8},{"hierarchy":{"lvl1":"5.1 for-Schleifen","lvl2":"for-Schleifen mit range()"},"content":"In vielen Fällen möchten wir eine Schleife für eine bestimmte Anzahl von\nIterationen ausführen. In Python können wir dies mit Hilfe der\nrange()-Funktion erreichen. Die range()-Funktion generiert ein spezielles\nObjekt von Zahlen, die wir dann anschließend in einer for-Schleife verwenden\nkönnen. Natürlich kann die Folge von Zahlen auch für andere Dinge genutzt\nwerden, aber die Verwendung für for-Schleifen ist sicherlich der häufigste\nEinsatzzweck von range().\n\nDie Syntax der range()-Funktion ist:range(stop)               # erzeugt Zahlen von 0 bis (stop - 1)\nrange(start, stop)        # erzeugt Zahlen von start bis (stop - 1)\nrange(start, stop, step)  # erzeugt Zahlen von start bis (stop - 1) mit der Schrittweite step\n\nEs ist schwierig, sich den Inhalt von range() direkt anzuschauen. Am\neinfachsten ist es, die range()-Funktion direkt mit der for-Schleife zu\nkombinieren.for i in range(start, stop, step):\n    anweisungen\n\nHier ist i die Schleifenvariable, die nacheinander bei jedem Schleifendurchgang\ndie Werte in der von range() erzeugten Zahlenfolge annimmt. Im Folgenden\nfinden Sie einige Beispiele für die Verwendung von for-Schleifen mit range():\n\nfor i in range(5):\n    print(i)\n\n\n\nrange(5) erzeugt die Zahlen 0, 1, 2, 3, 4, die dann durch die\nprint()-Funktion nacheinander ausgegeben werden.\n\nfor i in range(2, 6):      \n    print(i)\n\n\n\nrange(2,6) erzeugt die Zahlen 2, 3, 4, 5. Achtung, die 6 gehört nicht dazu, da\ndas letzte Element der Zahlenfolge ja die stop-Zahl - 1 ist.\n\nfor i in range(1, 10, 2): \n    print(i)\n\n\n\nrange(1, 10, 2) erzeugt die Zahlen 1, 3, 5, 7, 9.\n\nUm die Bedeutung der Schrittweite step zu zeigen, können wir einmal eine\nnegative Schrittweite ausprobieren.\n\nfor i in range(10, 0, -1):\n    print(i)\n\n\n\nDie negative Schrittweite step = -1 führt dazu, dass der Python-Interpreter\nrückwärts zählt.\n\nMini-Übung\n\nGeben Sie die Temperaturen von 0 °C bis 100 °C in 10 °C-Schritten aus.\n\n# Code-Zelle\n\n\n\nLösungfor i in range(0, 101, 10):\n    print(i, '°C')\n\nInsbesondere, wenn die Anzahl der Wiederholungen feststeht, kommt die\nfor-Schleife in Kombination mit range() zum Einsatz. Im Folgenden sehen wir\nuns ein Beispiel dazu an.\n\nDie Faustformel zur Berechnung des Bremsweges s_B in Metern (ohne\nReaktionszeit) lautets_B=\\frac{v^2}{100},\n\nwobei die Geschwindigkeit v des Autos in km/h angegeben wird. Natürlich\nvariiert der tatsächliche Bremsweg abhängig von der Straßenoberfläche (trocken /\nnass / vereist) oder dem Fahrzeugtyp (insbesondere Leistung der Bremse). Mit\neiner for-Schleife und range()erstellen wir eine Tabelle mit Bremswegen.\n\nfor v in range(30, 131, 10):\n    bremsweg = v**2 / 100\n    print(\"v =\", v, \"km/h,  Bremsweg =\", bremsweg, \"m\")\n\n\n\nMini-Übung\n\nNeben dem Bremsweg spielt auch der Reaktionsweg eine wichtige Rolle beim\nAnhalten eines Fahrzeugs. Während der Reaktionszeit von ca. 1 Sekunde legt\ndas Fahrzeug noch den folgenden Weg zurück:s_R = \\frac{v}{3.6}\n\nwobei v in km/h angegeben wird. Der gesamte Anhalteweg ergibt sich dann als\nSumme aus Reaktionsweg und Bremsweg:s_{gesamt} = s_R + s_B = \\frac{v}{3.6} + \\frac{v^2}{100}\n\nBerechnen Sie den gesamten Anhalteweg für Geschwindigkeiten von 30 km/h bis\n130 km/h in 10er-Schritten und geben Sie die Ergebnisse aus.\n\n# Code-Zelle\n\n\n\nLösungfor v in range(30, 131, 10):\n    reaktionsweg = v / 3.6\n    bremsweg = v**2 / 100\n    anhalteweg = reaktionsweg + bremsweg\n    print(\"v =\", v, \"km/h,  Anhalteweg =\", anhalteweg, \"m\")\n\nDie Ausgabe enthält viele Nachkommastellen, da Python mit Gleitkommazahlen rechnet. Wir könnten die Ausgabe mit f-strings formatieren:    print(f\"v = {v} km/h,  Anhalteweg = {anhalteweg:.1f} m\")\n\nAuf f-strings kommen wir in einem späteren Kapitel zurück.\n\nVideo “for-Schleife mit range()” von Programmieren Starten","type":"content","url":"/chapter05-sec01#for-schleifen-mit-range","position":9},{"hierarchy":{"lvl1":"5.1 for-Schleifen","lvl2":"Zusammenfassung und Ausblick"},"type":"lvl2","url":"/chapter05-sec01#zusammenfassung-und-ausblick","position":10},{"hierarchy":{"lvl1":"5.1 for-Schleifen","lvl2":"Zusammenfassung und Ausblick"},"content":"In diesem Kapitel haben wir gelernt, wie man in Python for-Schleifen verwendet,\num Wiederholungen umzusetzen. Wir haben zwei Varianten kennengelernt: die\nfor-Schleife mit Liste und die for-Schleife mit der range()-Funktion. Dabei\nhaben wir Begriffe wie Schleifenvariable, Kopfzeile und Einrückung eingeführt\nund deren Bedeutung erklärt. Anhand von Beispielen und Übungen haben wir\ngesehen, wie man Aufzählungen von Zahlen oder Texten durchläuft und die Elemente\nweiterverarbeitet. Außerdem haben wir gelernt, wie man mit range()\nZahlenfolgen erzeugt. Im nächsten Kapitel werden wir das Thema Strings erneut\naufgreifen und vertiefen.","type":"content","url":"/chapter05-sec01#zusammenfassung-und-ausblick","position":11},{"hierarchy":{"lvl1":"5.2 Balkendiagramme"},"type":"lvl1","url":"/chapter05-sec02","position":0},{"hierarchy":{"lvl1":"5.2 Balkendiagramme"},"content":"Im letzten Kapitel haben wir Ergebnisse von Berechnungen als Tabelle auf dem\nBildschirm ausgegeben. In diesem Kapitel kombinieren wir for-Schleifen mit\nPlotly Express, um Daten zu visualisieren. Dazu verwenden wir ein typisches\nMuster: Wir initialisieren leere Listen, füllen sie in der Schleife mit\nberechneten Werten und übergeben sie anschließend an Plotly Express.","type":"content","url":"/chapter05-sec02","position":1},{"hierarchy":{"lvl1":"5.2 Balkendiagramme","lvl2":"Lernziele"},"type":"lvl2","url":"/chapter05-sec02#lernziele","position":2},{"hierarchy":{"lvl1":"5.2 Balkendiagramme","lvl2":"Lernziele"},"content":"Lernziele\n\nSie können mit einer for-Schleife Listen mit Berechnungsergebnissen\nfüllen und diese mit Plotly Express visualisieren.\n\nSie können mit px.bar()  Balkendiagramme erstellen.","type":"content","url":"/chapter05-sec02#lernziele","position":3},{"hierarchy":{"lvl1":"5.2 Balkendiagramme","lvl2":"Liniendiagramm mit for-Schleife"},"type":"lvl2","url":"/chapter05-sec02#liniendiagramm-mit-for-schleife","position":4},{"hierarchy":{"lvl1":"5.2 Balkendiagramme","lvl2":"Liniendiagramm mit for-Schleife"},"content":"Im vorherigen Kapitel haben wir den Bremsweg für verschiedene Geschwindigkeiten\nals Tabelle ausgegeben. Jetzt visualisieren wir dieselben Daten als\nLiniendiagramm. Dazu erzeugen wir zunächst mit einer for-Schleife zwei Listen,\neine für die Geschwindigkeiten und eine für die zugehörigen Bremswege. Beide\nListen übergeben wir an Plotly Express.\n\nimport plotly.express as px\n\ngeschwindigkeiten = []\nbremswege = []\n\nfor v in range(0, 131, 10):\n    geschwindigkeiten.append(v)\n    bremswege.append(v**2 / 100)\n\nfig = px.line(x=geschwindigkeiten, y=bremswege,\n              labels={\"x\": \"Geschwindigkeit (km/h)\",\n                      \"y\": \"Bremsweg (m)\"},\n              title=\"Bremsweg in Abhängigkeit der Geschwindigkeit\")\nfig.show()\n\n\n\n\n\nDas Muster, das wir hier verwenden, ist typisch für die Kombination von\nfor-Schleife und Plotly Express: Wir initialisieren leere Listen, füllen sie in\nder Schleife mit berechneten Werten und übergeben sie anschließend an die\nVisualisierungsfunktion.\n\nMini-Übung\n\nErstellen Sie analog zum Bremsweg-Beispiel ein Liniendiagramm für den\nAnhalteweg in Abhängigkeit der Geschwindigkeit. Der Anhalteweg ergibt sich als\nSumme aus Reaktionsweg und Bremsweg:s_{gesamt} = \\frac{v}{3.6} + \\frac{v^2}{100}\n\nVerwenden Sie denselben Geschwindigkeitsbereich von 0 km/h bis 130 km/h.\n\n# Code-Zelle\n\n\n\nLösungimport plotly.express as px\n\ngeschwindigkeiten = []\nanhaltewege = []\n\nfor v in range(0, 131, 10):\n    geschwindigkeiten.append(v)\n    anhaltewege.append(v / 3.6 + v**2 / 100)\n\nfig = px.line(x=geschwindigkeiten, y=anhaltewege,\n              labels={\"x\": \"Geschwindigkeit (km/h)\",\n                      \"y\": \"Anhalteweg (m)\"},\n              title=\"Anhalteweg in Abhängigkeit der Geschwindigkeit\")\nfig.show()","type":"content","url":"/chapter05-sec02#liniendiagramm-mit-for-schleife","position":5},{"hierarchy":{"lvl1":"5.2 Balkendiagramme","lvl2":"Balkendiagramm"},"type":"lvl2","url":"/chapter05-sec02#balkendiagramm","position":6},{"hierarchy":{"lvl1":"5.2 Balkendiagramme","lvl2":"Balkendiagramm"},"content":"Bisher haben wir px.line() verwendet, um kontinuierliche Verläufe\ndarzustellen. Für kategoriale Daten (= Daten, die zu bestimmten Kategorien\ngehören und nicht auf einer kontinuierlichen Skala liegen) eignet sich ein\nBalkendiagramm besser. In Plotly Express erstellen wir Balkendiagramme mit\npx.bar().\n\nAls Beispiel greifen wir das Wahlergebnis aus dem letzten Kapitel auf. Dort\nhaben wir die Stimmen für Anna, Bob und ungültige Stimmen gezählt:\n\nanzahl_anna = 0\nanzahl_bob = 0\nanzahl_gesamt = 0\n\nfor zettel in [\"Bob\", \"Anna\", \"Anna\", \"Charlie\", \"Anna\", \"Bob\", \"Anna\"]:\n    anzahl_gesamt = anzahl_gesamt + 1\n    if zettel == \"Anna\":\n        anzahl_anna = anzahl_anna + 1\n    if zettel == \"Bob\":\n        anzahl_bob = anzahl_bob + 1\n\nanzahl_ungueltig = anzahl_gesamt - anzahl_anna - anzahl_bob\n\n\n\nDiese Ergebnisse visualisieren wir jetzt als Balkendiagramm:\n\nfig = px.bar(x=['Anna', 'Bob', 'ungültig'],\n             y=[anzahl_anna, anzahl_bob, anzahl_ungueltig],\n             labels={'x': 'Kandidat', 'y': 'Anzahl Stimmen'},\n             title='Ergebnis der Vereinswahl')\nfig.show()\n\n\n\nDie Syntax von px.bar() ist dieselbe wie bei px.line(): Wir übergeben die\nKategorien als Liste an x und die zugehörigen Werte als Liste an y.\n\nMini-Übung\n\nBei der nächsten Vereinswahl treten drei Kandidaten an: Anna, Bob und Clara.\nDie Wahlzettel lauten:\n\n[\"Bob\", \"Anna\", \"Clara\", \"Anna\", \"Bob\", \"Clara\", \"Clara\", \"Anna\", \"Bob\", \"Clara\"]\n\nZählen Sie die Stimmen für alle drei Kandidaten und stellen Sie das Ergebnis\nals Balkendiagramm dar.\n\n# Code-Zelle\n\n\n\nLösungimport plotly.express as px\n\nanzahl_anna = 0\nanzahl_bob = 0\nanzahl_clara = 0\n\nfor zettel in [\"Bob\", \"Anna\", \"Clara\", \"Anna\", \"Bob\",\n               \"Clara\", \"Clara\", \"Anna\", \"Bob\", \"Clara\"]:\n    if zettel == \"Anna\":\n        anzahl_anna = anzahl_anna + 1\n    if zettel == \"Bob\":\n        anzahl_bob = anzahl_bob + 1\n    if zettel == \"Clara\":\n        anzahl_clara = anzahl_clara + 1\n\nfig = px.bar(x=[\"Anna\", \"Bob\", \"Clara\"],\n             y=[anzahl_anna, anzahl_bob, anzahl_clara],\n             labels={\"x\": \"Kandidat\", \"y\": \"Anzahl Stimmen\"},\n             title=\"Ergebnis der Vereinswahl\")\nfig.show()","type":"content","url":"/chapter05-sec02#balkendiagramm","position":7},{"hierarchy":{"lvl1":"5.2 Balkendiagramme","lvl2":"Zusammenfassung und Ausblick"},"type":"lvl2","url":"/chapter05-sec02#zusammenfassung-und-ausblick","position":8},{"hierarchy":{"lvl1":"5.2 Balkendiagramme","lvl2":"Zusammenfassung und Ausblick"},"content":"In diesem Kapitel haben wir gelernt, wie man for-Schleifen mit Plotly Express\nkombiniert. Wir haben das typische Muster kennengelernt, bei dem leere Listen\ninitialisiert, in der Schleife mit Werten gefüllt und anschließend an Plotly\nExpress übergeben werden. Mit px.bar() haben wir einen neuen Diagrammtyp für\nkategoriale Daten kennengelernt. Im nächsten Kapitel werden wir das Thema\nStrings erneut aufgreifen und vertiefen.","type":"content","url":"/chapter05-sec02#zusammenfassung-und-ausblick","position":9},{"hierarchy":{"lvl1":"Übungen"},"type":"lvl1","url":"/chapter05-sec03","position":0},{"hierarchy":{"lvl1":"Übungen"},"content":"Übung 5.1 (✩)\n\nGegeben ist folgende Liste mit Werkstoffen:materialien = [\"Stahl\", \"Aluminium\", \"Titan\", \"Kupfer\"]\n\nSchreiben Sie ein Programm, das mit einer for-Schleife jedes Material\nnummeriert ausgibt. Die Ausgabe soll folgendes Format haben:Material 1: Stahl\nMaterial 2: Aluminium\nMaterial 3: Titan\nMaterial 4: Kupfer\n\nHinweis: Verwenden Sie eine zusätzliche Zählvariable, die Sie vor der Schleife\nauf 1 setzen und in jedem Schleifendurchgang um 1 erhöhen.\n\n# Code-Zelle\n\n\n\nLösungmaterialien = [\"Stahl\", \"Aluminium\", \"Titan\", \"Kupfer\"]\n\nnummer = 1\nfor material in materialien:\n    print(\"Material \" + str(nummer) + \": \" + material)\n    nummer = nummer + 1\n\nAusgabe:Material 1: Stahl\nMaterial 2: Aluminium\nMaterial 3: Titan\nMaterial 4: Kupfer\n\nErklärung: Die Variable nummer wird vor der Schleife auf 1 initialisiert.\nIn jedem Schleifendurchgang nimmt die Schleifenvariable material den nächsten\nWert aus der Liste an. Da nummer eine Ganzzahl (Integer) ist, muss sie mit\nstr() in einen String umgewandelt werden, bevor sie mit + verkettet werden\nkann. Am Ende jedes Durchgangs wird nummer um 1 erhöht, damit beim nächsten\nDurchgang die nächste Nummer ausgegeben wird.\n\nÜbung 5.2 (✩)\n\nSchreiben Sie ein Programm, das den Benutzer oder die Benutzerin nach einer\nganzen Zahl fragt und anschließend das kleine Einmaleins für diese Zahl ausgibt.\n\nBeispiel: Wenn die Zahl 3 eingegeben wird, soll die Ausgabe so aussehen:1 x 3 = 3\n2 x 3 = 6\n3 x 3 = 9\n4 x 3 = 12\n5 x 3 = 15\n6 x 3 = 18\n7 x 3 = 21\n8 x 3 = 24\n9 x 3 = 27\n10 x 3 = 30\n\nVerwenden Sie eine for-Schleife mit range().\n\n# Code-Zelle\n\n\n\nLösung# Eingabe\nzahl = int(input(\"Für welche Zahl soll das Einmaleins ausgegeben werden? \"))\n\n# Verarbeitung und Ausgabe\nfor i in range(1, 11):\n    ergebnis = i * zahl \n    print(str(i) + \" x \" + str(zahl) + \" = \" + str(ergebnis))\n\nErklärung: range(1, 11) erzeugt die Zahlen 1 bis 10. Die obere Grenze 11\ngehört dabei nicht mehr zur Folge, da range() immer bis zur stop-Zahl minus 1\nzählt. In jedem Schleifendurchgang nimmt i nacheinander die Werte 1, 2, ...,\n10 an. Das Produkt zahl * i wird in der Variablen ergebnis gespeichert und\nanschließend ausgegeben.\n\nÜbung 5.3 (✩)\n\nBei rotierenden Maschinenteilen (z. B. Turbinenschaufeln oder Kupplungsscheiben)\nwirkt auf jedes Bauteil eine Fliehkraft. Diese hängt von der Drehzahl der\nMaschine ab und ist bei der Auslegung von Bauteilen zu berücksichtigen.\n\nDie Fliehkraft F in Newton berechnet sich nach der Formel:F = m \\cdot \\omega^2 \\cdot r\n\nDabei ist \\omega die Winkelgeschwindigkeit in rad/s, die sich aus der Drehzahl\nn in U/min wie folgt ergibt:\\omega = \\frac{2 \\pi \\cdot n}{60}\n\nGegeben sind folgende Werte:\n\nGröße\n\nWert\n\nMasse m\n\n2.0 kg\n\nRadius r\n\n0.3 m\n\nKreiszahl \\pi\n\n3.14159\n\nBerechnen Sie die Fliehkraft für Drehzahlen von 500 U/min bis 3000 U/min in\n500er-Schritten und geben Sie die Ergebnisse aus.\n\n# Code-Zelle\n\n\n\nLösung# Eingabe\nPI = 3.14159\nm_kg = 2.0\nr_m = 0.3\n\n# Verarbeitung und Ausgabe\nfor n in range(500, 3001, 500):\n    omega = 2 * PI * n / 60\n    F_N = m_kg * omega**2 * r_m\n    print(\"n = \" + str(n) + \" U/min,  F = \" + str(F_N) + \" N\")\n\nErklärung: PI wird als Konstante mit dem Wert 3.14159 definiert und in der\nBerechnung der Winkelgeschwindigkeit omega verwendet. Großbuchstaben für\nKonstanten sind eine bewährte Konvention in der Programmierung, die auf den\nersten Blick deutlich macht, dass sich dieser Wert im Programm nicht ändert\nsoll. range(500, 3001, 500) erzeugt die Zahlen 500, 1000, 1500, 2000, 2500,\n3000. Die obere Grenze muss 3001 lauten, damit 3000 noch enthalten ist. Die\nAusgabe enthält viele Nachkommastellen, da Python mit Gleitkommazahlen rechnet.\nIn einem späteren Kapitel werden wir NumPy kennenlernen, das u. a. eine\npräzisere Kreiszahl numpy.pi sowie komfortablere Möglichkeiten zur Berechnung\nsolcher Wertetabellen bereitstellt.\n\nÜbung 5.4 (✩✩)\n\nAn einem Hydrauliksystem werden während eines Belastungstests folgende\nDruckwerte in bar gemessen:druckwerte_bar = [8.5, 11.2, 13.7, 9.8, 15.1, 10.3, 12.6, 14.9, 7.4, 11.8]\n\nDer maximale Betriebsdruck beträgt 12.0 bar. Schreiben Sie ein Programm, das die\nMesspunkte nummeriert durchläuft und für jeden Wert eine der folgenden Meldungen\nausgibt:\n\nLiegt der Druck im zulässigen Bereich: \"Messung 1: 8.5 bar ==> OK\"\n\nÜberschreitet der Druck den Grenzwert: \"Messung 3: 13.7 bar ==> WARNUNG: Maximaldruck überschritten!\"\n\nStrukturieren Sie Ihren Code mit EVA-Kommentaren.\n\n# Code-Zelle\n\n\n\nLösung# Eingabe\ndruckwerte_bar = [8.5, 11.2, 13.7, 9.8, 15.1, 10.3, 12.6, 14.9, 7.4, 11.8]\nMAX_DRUCK_BAR = 12.0\n\n# Verarbeitung und Ausgabe\nnummer = 1\nfor druck in druckwerte_bar:\n    if druck <= MAX_DRUCK_BAR:\n        print(\"Messung \" + str(nummer) + \": \" + str(druck) + \" bar ==> OK\")\n    if druck > MAX_DRUCK_BAR:\n        print(\"Messung \" + str(nummer) + \": \" + str(druck) + \" bar ==> WARNUNG: Maximaldruck überschritten!\")\n    nummer = nummer + 1\n\nErklärung: In jedem Schleifendurchgang wird der aktuelle Druckwert druck\nmit dem Grenzwert MAX_DRUCK_BAR verglichen. Je nach Ergebnis wird eine der\nbeiden Meldungen ausgegeben. Beachten Sie, dass die beiden if-Bedingungen\nsich gegenseitig ausschließen: Ein Druckwert kann nicht gleichzeitig kleiner\noder gleich und größer als der Grenzwert sein. Die Zählvariable nummer wird\nwie in Übung 5.1 manuell mitgeführt und am Ende jedes Durchgangs um 1 erhöht.\n\nÜbung 5.5 (✩✩)\n\nBei einem Zugversuch wurden an zehn Stahlproben folgende Zugfestigkeitswerte in\nMegapascal (MPa) gemessen:zugfestigkeit_mpa = [512, 498, 521, 507, 489, 534, 503, 518, 495, 526]\n\nBerechnen Sie mit einer for-Schleife:\n\nden Minimalwert (kleinster Messwert),\n\nden Maximalwert (größter Messwert),\n\nden Mittelwert (Summe aller Werte geteilt durch die Anzahl).\n\nGeben Sie die drei Ergebnisse am Ende aus. Verwenden Sie ausschließlich\nfor-Schleifen und Zählervariablen. Die eingebauten Python-Funktionen min(),\nmax() und sum() sind für diese Übung nicht erlaubt.\n\nHinweis: Initialisieren Sie den Minimalwert und den Maximalwert mit dem ersten\nListenelement, bevor Sie die Schleife starten.\n\n# Code-Zelle\n\n\n\nLösung# Eingabe\nzugfestigkeit_mpa = [512, 498, 521, 507, 489, 534, 503, 518, 495, 526]\n\n# Verarbeitung\nminimalwert = zugfestigkeit_mpa[0]\nmaximalwert = zugfestigkeit_mpa[0]\nsumme = 0\nanzahl = 0\n\nfor wert in zugfestigkeit_mpa:\n    if wert < minimalwert:\n        minimalwert = wert\n    if wert > maximalwert:\n        maximalwert = wert\n    summe = summe + wert\n    anzahl = anzahl + 1\n\nmittelwert = summe / anzahl\n\n# Ausgabe\nprint(\"Minimalwert: \" + str(minimalwert) + \" MPa\")\nprint(\"Maximalwert: \" + str(maximalwert) + \" MPa\")\nprint(\"Mittelwert:  \" + str(mittelwert) + \" MPa\")\n\nErklärung: minimalwert und maximalwert werden mit dem ersten Listenelement\ninitialisiert. Das ist wichtig: Würde man mit 0 initialisieren, wäre\nminimalwert nach der Schleife immer 0, da alle Messwerte größer als 0\nsind. In jedem Schleifendurchgang wird der aktuelle Wert mit dem bisherigen\nMinimal- und Maximalwert verglichen und bei Bedarf ersetzt. Die Variable\nsumme summiert alle Werte, anzahl zählt die Durchläufe. Der Mittelwert\nwird erst nach der Schleife aus beiden berechnet.\n\nÜbung 5.6 (✩✩)\n\nDas Hooke’sche Gesetz beschreibt den linearen Zusammenhang zwischen der\nFederkraft F und der Auslenkung x einer Feder:F = k \\cdot x\n\nDabei ist k die Federkonstante in N/mm und x die Auslenkung in mm.\n\nGegeben ist eine Feder mit der Federkonstante k = 3.5 N/mm. Erstellen Sie\nmit einer for-Schleife zwei Listen:\n\nauslenkung_mm: Auslenkungen von 0 mm bis 100 mm in 5-mm-Schritten,\n\nfederkraft_n: die zugehörigen Federkräfte in Newton.\n\nVisualisieren Sie anschließend die Federkraft in Abhängigkeit der Auslenkung\nals Liniendiagramm mit Titel und Achsenbeschriftungen.\n\n# Code-Zelle\n\n\n\nLösungimport plotly.express as px\n\n# Eingabe\nk_n_mm = 3.5\n\n# Verarbeitung\nauslenkung_mm = []\nfederkraft_n = []\n\nfor x in range(0, 101, 5):\n    auslenkung_mm.append(x)\n    federkraft_n.append(k_n_mm * x)\n\n# Ausgabe\nfig = px.line(x=auslenkung_mm, y=federkraft_n,\n              title=\"Federkraft nach Hooke'schem Gesetz\",\n              labels={\"x\": \"Auslenkung in mm\", \"y\": \"Federkraft in N\"})\nfig.show()\n\nErklärung: Vor der Schleife werden zwei leere Listen initialisiert. In jedem\nSchleifendurchgang wird die aktuelle Auslenkung x an auslenkung_mm\nangehängt und die zugehörige Federkraft k_n_mm * x an federkraft_n.\nrange(0, 101, 5) erzeugt die Werte 0, 5, 10, ..., 100. Die obere Grenze\nmuss 101 lauten, damit 100 noch enthalten ist. Nach der Schleife werden beide\nListen an Plotly Express übergeben. Dieses Muster (leere Listen initialisieren,\nin der Schleife befüllen, anschließend visualisieren) werden wir in späteren\nKapiteln häufig verwenden.\n\nÜbung 5.7 (✩✩)\n\nIn einer Fertigung wurden 15 Bauteile produziert und ihr Material dokumentiert:materialien = [\"Stahl\", \"Aluminium\", \"Stahl\", \"Kunststoff\", \"Stahl\",\n               \"Aluminium\", \"Stahl\", \"Kunststoff\", \"Aluminium\", \"Stahl\",\n               \"Kunststoff\", \"Stahl\", \"Aluminium\", \"Stahl\", \"Kunststoff\"]\n\nSchreiben Sie ein Programm, das mit einer for-Schleife die Häufigkeit jedes\nMaterials zählt und das Ergebnis als Balkendiagramm darstellt.\n\nStrukturieren Sie Ihren Code mit EVA-Kommentaren.\n\n# Code-Zelle\n\n\n\nLösungimport plotly.express as px\n\n# Eingabe\nmaterialien = [\"Stahl\", \"Aluminium\", \"Stahl\", \"Kunststoff\", \"Stahl\",\n               \"Aluminium\", \"Stahl\", \"Kunststoff\", \"Aluminium\", \"Stahl\",\n               \"Kunststoff\", \"Stahl\", \"Aluminium\", \"Stahl\", \"Kunststoff\"]\n\n# Verarbeitung\nanzahl_stahl = 0\nanzahl_aluminium = 0\nanzahl_kunststoff = 0\n\nfor material in materialien:\n    if material == \"Stahl\":\n        anzahl_stahl = anzahl_stahl + 1\n    if material == \"Aluminium\":\n        anzahl_aluminium = anzahl_aluminium + 1\n    if material == \"Kunststoff\":\n        anzahl_kunststoff = anzahl_kunststoff + 1\n\n# Ausgabe\nfig = px.bar(x=[\"Stahl\", \"Aluminium\", \"Kunststoff\"],\n             y=[anzahl_stahl, anzahl_aluminium, anzahl_kunststoff],\n             labels={\"x\": \"Material\", \"y\": \"Anzahl Bauteile\"},\n             title=\"Materialverteilung in der Fertigung\")\nfig.show()\n\nErklärung: Die drei Zählvariablen werden vor der Schleife auf 0 initialisiert.\nIn jedem Durchgang wird das aktuelle Material mit den drei bekannten Werten\nverglichen und der passende Zähler um 1 erhöht. Nach der Schleife werden die\ngezählten Häufigkeiten als Listen an px.bar() übergeben.\n\nÜbung 5.8 (✩✩✩)\n\nIn der Qualitätssicherung werden gefertigte Bolzen vermessen. Der Soll-Durchmesser\nbeträgt 25.0 mm, und die zulässige Toleranz liegt bei +/- 0.3 mm. Bolzen\naußerhalb dieser Toleranz gelten als Ausschuss.\n\nDie Messwerte von 12 Bolzen in Millimetern sind:durchmesser_mm = [25.1, 24.6, 25.3, 25.0, 24.7, 25.4,\n                  24.9, 25.2, 24.5, 25.1, 25.3, 24.8]\n\nSchreiben Sie ein Programm, das:\n\njeden Bolzen prüft und als “iO” (in Ordnung) oder “niO” (nicht in Ordnung,\nd.h. Ausschuss) klassifiziert,\n\ndie Anzahl der iO-Teile und niO-Teile zählt,\n\ndie Ausschussquote in Prozent berechnet und ausgibt,\n\ndie Klassifizierung als Balkendiagramm visualisiert.\n\nDefinieren Sie den Sollwert und die Toleranz als Konstanten. Strukturieren Sie\nIhren Code mit EVA-Kommentaren.\n\nHinweis: Verwenden Sie eine Hilfsvariable ist_fehlerhaft, die Sie zu Beginn\njedes Schleifendurchgangs auf False setzen und auf True setzen, sobald der\nDurchmesser die untere oder obere Grenze verletzt.\n\n# Code-Zelle\n\n\n\nLösungimport plotly.express as px\n\n# Eingabe\ndurchmesser_mm = [25.1, 24.6, 25.3, 25.0, 24.7, 25.4,\n                  24.9, 25.2, 24.5, 25.1, 25.3, 24.8]\nSOLL_MM = 25.0\nTOLERANZ_MM = 0.3\nGRENZE_UNTEN_MM = SOLL_MM - TOLERANZ_MM\nGRENZE_OBEN_MM = SOLL_MM + TOLERANZ_MM\n\n# Verarbeitung\nanzahl_iO = 0\nanzahl_niO = 0\n\nfor d in durchmesser_mm:\n    ist_fehlerhaft = False\n    if d < GRENZE_UNTEN_MM:\n        ist_fehlerhaft = True\n    if d > GRENZE_OBEN_MM:\n        ist_fehlerhaft = True\n    if ist_fehlerhaft == True:\n        anzahl_niO = anzahl_niO + 1\n    if ist_fehlerhaft == False:\n        anzahl_iO = anzahl_iO + 1\n\nanzahl_gesamt = anzahl_iO + anzahl_niO\nausschussquote = anzahl_niO / anzahl_gesamt * 100\n\n# Ausgabe\nprint(\"iO-Teile:       \" + str(anzahl_iO))\nprint(\"niO-Teile:      \" + str(anzahl_niO))\nprint(\"Ausschussquote: \" + str(ausschussquote) + \" %\")\n\nfig = px.bar(x=[\"iO-Teile\", \"niO-Teile\"],\n             y=[anzahl_iO, anzahl_niO],\n             labels={\"x\": \"Klassifizierung\", \"y\": \"Anzahl Bolzen\"},\n             title=\"Ergebnis der Qualitätsprüfung\")\nfig.show()\n\nErklärung: Die Grenzen werden vor der Schleife als Konstanten berechnet, damit\ndie Berechnung nicht in jedem Durchgang wiederholt wird. Die Hilfsvariable\nist_fehlerhaft ist vom Typ Bool und wird zu Beginn jedes Schleifendurchgangs\nauf False gesetzt. Wird die untere oder obere Grenze verletzt, springt sie\nauf True. Am Ende jedes Durchgangs entscheiden zwei if-Abfragen auf Basis\nvon ist_fehlerhaft, welchen Zähler sie erhöhen. Dieses Muster mit einer\nBool-Variablen, die einen Zustand speichert, nennt man in der Programmierung\nein Flag. Die Ausschussquote enthält viele Nachkommastellen. In einem\nspäteren Kapitel werden wir lernen, die Ausgabe mit f-Strings zu formatieren.","type":"content","url":"/chapter05-sec03","position":1},{"hierarchy":{"lvl1":"6.1 Indizierung, Strings und f-Strings"},"type":"lvl1","url":"/chapter06-sec01","position":0},{"hierarchy":{"lvl1":"6.1 Indizierung, Strings und f-Strings"},"content":"In Kapitel 3 haben wir Listen kennengelernt und gelernt, wie man mit einem\npositiven Index auf einzelne Elemente zugreift. In der Praxis braucht man aber\nhäufig das letzte Element einer Sammlung, ohne deren genaue Länge zu kennen.\nAngenommen, wir erfassen laufend Temperaturmessungen an einer Bremsscheibe und\nmöchten jederzeit den aktuellsten Wert abrufen. Python bietet dafür den\nnegativen Index, den wir in diesem Kapitel kennenlernen. Danach vertiefen wir\nden Umgang mit Strings und lernen mit den sogenannten f-Strings eine elegante\nMethode kennen, Ausgaben sauber zu formatieren.","type":"content","url":"/chapter06-sec01","position":1},{"hierarchy":{"lvl1":"6.1 Indizierung, Strings und f-Strings","lvl2":"Lernziele"},"type":"lvl2","url":"/chapter06-sec01#lernziele","position":2},{"hierarchy":{"lvl1":"6.1 Indizierung, Strings und f-Strings","lvl2":"Lernziele"},"content":"Lernziele\n\nSie können mit einem negativen Index auf das letzte und vorletzte\nElement einer Liste zugreifen.\n\nSie können Strings wie Listen indizieren und kennen den wichtigsten\nUnterschied: Strings sind unveränderlich.\n\nSie können mit f-Strings Ausgaben formatieren und Zahlen auf eine\nbestimmte Anzahl von Nachkommastellen runden.","type":"content","url":"/chapter06-sec01#lernziele","position":3},{"hierarchy":{"lvl1":"6.1 Indizierung, Strings und f-Strings","lvl2":"Negativer Index"},"type":"lvl2","url":"/chapter06-sec01#negativer-index","position":4},{"hierarchy":{"lvl1":"6.1 Indizierung, Strings und f-Strings","lvl2":"Negativer Index"},"content":"Betrachten wir eine Liste mit Messwerten der Bremsscheibentemperatur, die\nwährend eines Bremsvorgangs aufgezeichnet wurden:\n\ntemperaturen = [80, 145, 210, 265, 305, 335, 350]\n\n\n\nMit einem positiven Index greifen wir von vorne auf die Liste zu: temperaturen[0]\nliefert den ersten Wert, temperaturen[1] den zweiten und so weiter. Der letzte\nWert befindet sich an Index len(temperaturen) - 1, also an Index 6. Das ist\numständlich, vor allem wenn sich die Länge der Liste im Laufe des Programms\nändert.\n\nPython bietet dafür eine elegante Lösung: den negativen Index. Der Index\n-1 bezeichnet immer das letzte Element, -2 das vorletzte und so weiter.\n\ntemperaturen = [80, 145, 210, 265, 305, 335, 350]\n\nprint(temperaturen[-1])   # letztes Element:      350\nprint(temperaturen[-2])   # vorletztes Element:   335\nprint(temperaturen[-7])   # erstes Element:        80\n\n\n\nDer negative Index und der positive Index sind zwei Sichtweisen auf dieselbe\nListe. Die folgende Tabelle zeigt die Entsprechungen für unsere Temperaturliste:\n\nPosition\n\npositiver Index\n\nnegativer Index\n\nWert\n\n1. Element\n\n0\n\n-7\n\n80\n\n2. Element\n\n1\n\n-6\n\n145\n\n3. Element\n\n2\n\n-5\n\n210\n\n4. Element\n\n3\n\n-4\n\n265\n\n5. Element\n\n4\n\n-3\n\n305\n\n6. Element\n\n5\n\n-2\n\n335\n\n7. Element\n\n6\n\n-1\n\n350\n\nIn der Praxis verwendet man fast ausschließlich -1 und gelegentlich -2. Die\nweiteren negativen Indizes sind selten sinnvoll, da man dann besser mit einem\npositiven Index arbeitet.\n\nMini-Übung\n\nGegeben ist folgende Liste mit Bauteilbezeichnungen:bauteile = [\"Welle\", \"Lager\", \"Dichtung\", \"Schraube\", \"Mutter\"]\n\nGeben Sie das erste Bauteil mit positivem und das letzte Bauteil mit negativem Index\naus.\n\nGeben Sie das vorletzte Bauteil aus.\n\nWelches Ergebnis liefert bauteile[-3]? Überlegen Sie zuerst, bevor Sie den\nCode ausführen.\n\n# Code-Zelle\n\n\n\nLösungbauteile = [\"Welle\", \"Lager\", \"Dichtung\", \"Schraube\", \"Mutter\"]\n\n# 1. Erstes und letztes Bauteil\nprint(bauteile[0])    # Welle\nprint(bauteile[-1])   # Mutter\n\n# 2. Vorletztes Bauteil\nprint(bauteile[-2])   # Schraube\n\n# 3. Drittes Element von hinten\nprint(bauteile[-3])   # Dichtung\n\nbauteile[-3] liefert \"Dichtung\", da von hinten gezählt das dritte Element an\nIndex 2 von vorne liegt (bei einer Liste mit 5 Elementen gilt: -3 --> 5 - 3 =\n2).","type":"content","url":"/chapter06-sec01#negativer-index","position":5},{"hierarchy":{"lvl1":"6.1 Indizierung, Strings und f-Strings","lvl2":"Strings indizieren"},"type":"lvl2","url":"/chapter06-sec01#strings-indizieren","position":6},{"hierarchy":{"lvl1":"6.1 Indizierung, Strings und f-Strings","lvl2":"Strings indizieren"},"content":"Strings verhalten sich beim Indizieren ähnlich wie Listen. Auch ein String hat\neinen Index, jedes Zeichen hat seine eigene Position innerhalb des Strings. Der\nString \"Welle\" hat fünf Zeichen, die über den Index 0 bis 4 (bzw. -1 bis\n-5) angesprochen werden können.\n\nbauteil = \"Welle\"\n\nprint(bauteil[0])    # erstes Zeichen:  W\nprint(bauteil[-1])   # letztes Zeichen: e\nprint(len(bauteil))  # Länge:           5\n\n\n\nDie Funktion len(), die wir aus dem Kapitel für Listen kennen, funktioniert\nalso auch für Strings und liefert die Anzahl der Zeichen.\n\nHier endet jedoch die Ähnlichkeit mit Listen. Der wichtigste Unterschied ist,\ndass Strings unveränderlich sind. Das bedeutet: Einzelne Zeichen eines\nStrings können nachträglich nicht ausgetauscht werden. Der folgende Versuch führt\ndaher zu einem Fehler:\n\nbauteil = \"Welle\"\nbauteil[0] = \"K\"   # TypeError: 'str' object does not support item assignment\n\n\n\nBei einer Liste ist derselbe Schreibzugriff problemlos möglich:\n\nbauteile = [\"Welle\", \"Lager\", \"Dichtung\"]\nbauteile[0] = \"Kurbelwelle\"\nprint(bauteile)\n\n\n\nMöchte man einen String verändern, muss man stattdessen einen neuen String\nerzeugen. Das kann zum Beispiel durch String-Verkettung mit + geschehen, wie\nwir es in Kapitel 2 gelernt haben.\n\nMini-Übung\n\nGegeben ist die Bauteilbezeichnung \"Antriebswelle_v1\".\n\nGeben Sie das erste und das letzte Zeichen des Strings aus.\n\nBestimmen Sie die Länge des Strings.\n\nPrüfen Sie mit einer if-Bedingung, ob das letzte Zeichen \"1\" ist, und\ngeben Sie in diesem Fall \"Bauteil hat Version 1.\" aus.\n\nErzeugen Sie den String \"Antriebswelle_v1_FINAL\" durch Verkettung und\ngeben Sie ihn aus.\n\n# Code-Zelle\n\n\n\nLösungbauteil = \"Antriebswelle_v1\"\n\n# 1. Erstes und letztes Zeichen\nprint(bauteil[0])    # A\nprint(bauteil[-1])   # 1\n\n# 2. Länge\nprint(len(bauteil))  # 16\n\n# 3. Letzte Zeichen prüfen\nif bauteil[-1] == \"1\":\n    print(\"Bauteil hat Version 1.\")\n\n# 4. String verketten\nbauteil_final = bauteil + \"_FINAL\"\nprint(bauteil_final)   # Antriebswelle_v1_FINAL","type":"content","url":"/chapter06-sec01#strings-indizieren","position":7},{"hierarchy":{"lvl1":"6.1 Indizierung, Strings und f-Strings","lvl2":"f-Strings"},"type":"lvl2","url":"/chapter06-sec01#f-strings","position":8},{"hierarchy":{"lvl1":"6.1 Indizierung, Strings und f-Strings","lvl2":"f-Strings"},"content":"In Kapitel 5 haben wir mehrfach festgestellt, dass Ausgaben mit vielen\nNachkommastellen unpraktisch sind. Bisher haben wir Variablen mit str() in\nStrings umgewandelt und mit + verkettet:\n\nbremsweg = 24.336734693877552\nprint(\"Bremsweg: \" + str(bremsweg) + \" m\")\n\n\n\nDas ist lesbar, aber umständlich. Mit f-Strings geht das deutlich eleganter.\nEin f-String beginnt mit dem Buchstaben f vor den Anführungszeichen. Innerhalb\ndes Strings können Variablen direkt in geschweiften Klammern { } eingebettet\nwerden:\n\nbremsweg = 24.336734693877552\nprint(f\"Bremsweg: {bremsweg} m\")\n\n\n\nDas Ergebnis ist identisch, aber der Code ist kürzer und besser lesbar. Das f\nsteht für das englische Wort “formatted”.\n\nDer eigentliche Mehrwert von f-Strings liegt in der Möglichkeit, Zahlen direkt\nzu formatieren. Innerhalb der geschweiften Klammern kann nach einem Doppelpunkt\nein Formatierungsausdruck angegeben werden:\n\nbremsweg = 24.336734693877552\n\nprint(f\"Bremsweg: {bremsweg:.1f} m\")   # 1 Nachkommastelle\nprint(f\"Bremsweg: {bremsweg:.2f} m\")   # 2 Nachkommastellen\nprint(f\"Bremsweg: {bremsweg:.0f} m\")   # 0 Nachkommastellen (Ganzzahl)\n\n\n\nDer Formatierungsausdruck :.2f bedeutet: Fließkommazahl (f) mit 2\nNachkommastellen (.2). Die Zahl wird dabei automatisch gerundet.\n\nGanzzahlen können ebenfalls formatiert werden, zum Beispiel mit einer\nMindestbreite für die Ausgabe:\n\nfor v in range(30, 131, 10):\n    bremsweg = v**2 / 100\n    print(f\"v = {v:3d} km/h,  Bremsweg = {bremsweg:6.2f} m\")\n\n\n\nHier bedeutet {v:3d}, dass die Ganzzahl (d für “decimal integer”) in einem\nFeld der Breite 3 ausgegeben wird. {bremsweg:6.2f} reserviert ein Feld der\nBreite 6 mit 2 Nachkommastellen. Das sorgt dafür, dass die Werte spaltenweise\nuntereinander ausgerichtet werden, was die Tabelle deutlich übersichtlicher\nmacht.\n\nMini-Übung\n\nIn einer früheren Übung haben wir die Fliehkraft für verschiedene Drehzahlen\nfolgendermaßen berechnet:PI = 3.14159\nm_kg = 2.0\nr_m = 0.3\n\nfor n in range(500, 3001, 500):\n    omega = 2 * PI * n / 60\n    F_N = m_kg * omega**2 * r_m\n    print(\"n = \" + str(n) + \" U/min,  F = \" + str(F_N) + \" N\")\n\nDie Ausgabe enthält viele Nachkommastellen. Verwenden Sie einen f-String, um die\nAusgabe so zu formatieren, dass die Drehzahlen und Fliehkräfte korrekt\nuntereinander angeordnet sind.\n\n# Code-Zelle\n\n\n\nLösungPI = 3.14159\nm_kg = 2.0\nr_m = 0.3\n\nfor n in range(500, 3001, 500):\n    omega = 2 * PI * n / 60\n    F_N = m_kg * omega**2 * r_m\n    print(f\"n = {n:4d} U/min,  F = {F_N:8.1f} N\")\n\nBeispielhafte Ausgabe:n =  500 U/min,  F =   1644.9 N\nn = 1000 U/min,  F =   6579.7 N\nn = 1500 U/min,  F =  14804.3 N\nn = 2000 U/min,  F =  26319.7 N\nn = 2500 U/min,  F =  41124.5 N\nn = 3000 U/min,  F =  59219.3 N\n\nDie Ausgabe ist durch die Feldbreiten jetzt spaltenweise ausgerichtet und\ndadurch deutlich übersichtlicher als die ursprüngliche Version mit\nString-Verkettung.","type":"content","url":"/chapter06-sec01#f-strings","position":9},{"hierarchy":{"lvl1":"6.1 Indizierung, Strings und f-Strings","lvl2":"Zusammenfassung und Ausblick"},"type":"lvl2","url":"/chapter06-sec01#zusammenfassung-und-ausblick","position":10},{"hierarchy":{"lvl1":"6.1 Indizierung, Strings und f-Strings","lvl2":"Zusammenfassung und Ausblick"},"content":"In diesem Kapitel haben wir den negativen Index kennengelernt, mit dem wir\nbequem auf das letzte Element einer Liste oder eines Strings zugreifen können,\nohne die genaue Länge zu kennen. Wir haben gesehen, dass Strings beim Indizieren\nwie Listen funktionieren, aber im Gegensatz zu Listen unveränderlich sind. Mit\nf-Strings haben wir schließlich ein mächtiges Werkzeug kennengelernt, das\nformatierte Ausgaben deutlich kompakter und lesbarer macht als die bisherige\nString-Verkettung. Im nächsten Kapitel lernen wir das numpy.random-Modul\nkennen und simulieren damit Zufallsprozesse aus dem Ingenieuralltag.","type":"content","url":"/chapter06-sec01#zusammenfassung-und-ausblick","position":11},{"hierarchy":{"lvl1":"6.2 Zufallszahlen und Simulation"},"type":"lvl1","url":"/chapter06-sec02","position":0},{"hierarchy":{"lvl1":"6.2 Zufallszahlen und Simulation"},"content":"Kein Fertigungsprozess ist absolut präzise. Ein gefertigter Bolzen, der einen\nSolldurchmesser von 25.0 mm haben soll, wird in der Realität mal 24.97 mm, mal\n25.04 mm oder 24.98 mm messen. Diese unvermeidliche Streuung ist ein zentrales\nThema in der Qualitätssicherung und der Konstruktion. Um solche Prozesse zu\nuntersuchen, ohne tatsächlich tausende Bauteile fertigen zu müssen, verwenden\nIngenieurinnen und Ingenieure Simulationen. In diesem Kapitel lernen wir\nmit numpy.random ein mächtiges Werkzeug kennen, das Zufallszahlen für genau\nsolche Simulationen bereitstellt.","type":"content","url":"/chapter06-sec02","position":1},{"hierarchy":{"lvl1":"6.2 Zufallszahlen und Simulation","lvl2":"Lernziele"},"type":"lvl2","url":"/chapter06-sec02#lernziele","position":2},{"hierarchy":{"lvl1":"6.2 Zufallszahlen und Simulation","lvl2":"Lernziele"},"content":"Lernziele\n\nSie kennen den Unterschied zwischen Gleichverteilung und\nNormalverteilung und können erklären, welches Modell für\nFertigungsstreuung realistischer ist.\n\nSie können NumPy mit dem Alias np importieren.\n\nSie können mit np.random.uniform() gleichverteilte Zufallszahlen\nerzeugen.\n\nSie können mit np.random.normal() normalverteilte Zufallszahlen erzeugen\nund kennen die Parameter Mittelwert und Standardabweichung.\n\nSie können mit px.histogram() die Verteilung von Zufallszahlen\nvisualisieren.","type":"content","url":"/chapter06-sec02#lernziele","position":3},{"hierarchy":{"lvl1":"6.2 Zufallszahlen und Simulation","lvl2":"Gleichverteilung und Normalverteilung"},"type":"lvl2","url":"/chapter06-sec02#gleichverteilung-und-normalverteilung","position":4},{"hierarchy":{"lvl1":"6.2 Zufallszahlen und Simulation","lvl2":"Gleichverteilung und Normalverteilung"},"content":"Bevor wir Zufallszahlen erzeugen, müssen wir uns fragen: Wie sind die Werte\nin der Realität verteilt? Zwei Modelle sind besonders wichtig.\n\nBei der Gleichverteilung ist jeder Wert innerhalb eines Bereichs gleich\nwahrscheinlich. Beispielsweise ist bei einem sechsseitigen Würfel jede Augenzahl\nvon 1 bis 6 gleich wahrscheinlich.\n\nBei der Normalverteilung liegen die meisten Werte nahe einem Mittelwert, und\nje weiter ein Wert vom Mittelwert entfernt ist, desto seltener tritt er auf. Das\nkennen wir aus dem Alltag: Die meisten Menschen haben eine Körpergröße nahe dem\nDurchschnitt, sehr kleine oder sehr große Menschen sind selten.\n\nFür einen Fertigungsprozess gilt: Die Maschine versucht, den Solldurchmesser\nzu treffen. Kleine Abweichungen passieren ständig, große Abweichungen sind\nselten. Das entspricht einer Normalverteilung. Eine Gleichverteilung würde\nbedeuten, dass ein Bolzen von 24.51 mm genauso häufig vorkommt wie einer von\n25.0 mm, was nicht realistisch ist.","type":"content","url":"/chapter06-sec02#gleichverteilung-und-normalverteilung","position":5},{"hierarchy":{"lvl1":"6.2 Zufallszahlen und Simulation","lvl2":"Zufallszahlen mit NumPy"},"type":"lvl2","url":"/chapter06-sec02#zufallszahlen-mit-numpy","position":6},{"hierarchy":{"lvl1":"6.2 Zufallszahlen und Simulation","lvl2":"Zufallszahlen mit NumPy"},"content":"NumPy ist das wichtigste Modul für wissenschaftliches Rechnen in Python. Es\nstellt unter anderem effiziente Funktionen für mathematische Operationen,\nlineare Algebra und Statistik bereit. In einem späteren Kapitel werden wir NumPy\nausführlich kennenlernen. Für dieses Kapitel interessiert uns zunächst nur ein\nTeilbereich: numpy.random, also die Zufallszahlen-Funktionen von NumPy.\n\nNumPy wird mit dem Standard-Alias np importiert:\n\nimport numpy as np\n\n\n\nDanach stehen alle NumPy-Funktionen über np. zur Verfügung.\n\nDie Funktion np.random.uniform(low, high) erzeugt eine gleichverteilte\nZufallszahl zwischen low und high, genauer gesagt im Intervall [low,\nhigh).\n\ndurchmesser = np.random.uniform(24.5, 25.5)\nprint(f\"Simulierter Durchmesser: {durchmesser:.3f} mm\")\n\n\n\nJedes Mal, wenn wir diesen Code ausführen, erhalten wir einen anderen Wert,\nder gleichmäßig zwischen 24.5 mm und 25.5 mm verteilt ist.\n\nDie Funktion np.random.normal(loc, scale) erzeugt eine normalverteilte\nZufallszahl. Der Parameter loc gibt den Mittelwert an, also den Wert, um\nden die Zufallszahlen zentriert sind. Der Parameter scale gibt die\nStandardabweichung an, also ein Maß dafür, wie breit die Streuung ist. Eine\nkleine Standardabweichung bedeutet einen präzisen Prozess, eine große bedeutet\nviel Streuung.\n\n# Bolzendurchmesser: Mittelwert 25.0 mm, Standardabweichung 0.15 mm\ndurchmesser = np.random.normal(25.0, 0.15)\nprint(f\"Simulierter Durchmesser: {durchmesser:.3f} mm\")\n\n\n\nHinweis für Fortgeschrittene\n\nSeit NumPy 1.17 empfiehlt NumPy die neue Generator-API mit\nrng = np.random.default_rng(). Wir verwenden hier den klassischen\nAufrufstil, der einsteigerfreundlicher ist und in der Praxis weit\nverbreitet bleibt.","type":"content","url":"/chapter06-sec02#zufallszahlen-mit-numpy","position":7},{"hierarchy":{"lvl1":"6.2 Zufallszahlen und Simulation","lvl2":"Verteilungen sichtbar machen: px.histogram()"},"type":"lvl2","url":"/chapter06-sec02#verteilungen-sichtbar-machen-px-histogram","position":8},{"hierarchy":{"lvl1":"6.2 Zufallszahlen und Simulation","lvl2":"Verteilungen sichtbar machen: px.histogram()"},"content":"Ein einzelner Zufallswert verrät wenig darüber, wie sich viele Werte verteilen.\nMit einem Histogramm können wir das sichtbar machen. Ein Histogramm teilt\nden Wertebereich in gleich breite Abschnitte (sogenannte Bins) und zählt, wie\nviele Werte in jeden Abschnitt fallen. Plotly Express stellt dafür die Funktion\npx.histogram() bereit, die wir in einem späteren Kapitel ausführlich\nkennenlernen werden. Für jetzt genügt es zu wissen, dass wir eine Liste von\nWerten übergeben und ein Histogramm erhalten.\n\nWir erzeugen 1000 gleichverteilte und 1000 normalverteilte Bolzendurchmesser\nund visualisieren beide als Histogramm:\n\nimport numpy as np\nimport plotly.express as px\n\n# 1000 gleichverteilte Durchmesser zwischen 24.5 mm und 25.5 mm\nwerte_gleichverteilt = []\nfor i in range(1000):\n    werte_gleichverteilt.append(np.random.uniform(24.5, 25.5))\n\n# 1000 normalverteilte Durchmesser: Mittelwert 25.0 mm, Standardabweichung 0.15 mm\nwerte_normalverteilt = []\nfor i in range(1000):\n    werte_normalverteilt.append(np.random.normal(25.0, 0.15))\n\n# Visualisierung gleichverteilte Bolzendurchmesser\nfig_gleich = px.histogram(x=werte_gleichverteilt,\n                          labels={\"x\": \"Durchmesser in mm\"},\n                          title=\"Gleichverteilung: 1000 simulierte Bolzen\")\nfig_gleich.update_yaxes(title_text=\"Häufigkeit\")\nfig_gleich.show()\n\n# Visualisierung normalverteilte Bolzendurchmesser\nfig_normal = px.histogram(x=werte_normalverteilt,\n                          labels={\"x\": \"Durchmesser in mm\"},\n                          title=\"Normalverteilung: 1000 simulierte Bolzen\")\nfig_normal.update_yaxes(title_text=\"Häufigkeit\")\nfig_normal.show()\n\n\n\n\n\n\n\nDas Histogramm der Gleichverteilung zeigt annähernd gleich hohe Balken über den\ngesamten Bereich. Das Histogramm der Normalverteilung zeigt die typische\nGlockenform: Werte nahe 25.0 mm treten am häufigsten auf, nach außen hin werden\ndie Balken immer kleiner.\n\nMini-Übung\n\nVerändern Sie die Standardabweichung der Normalverteilung auf 0.05 mm und dann\nauf 0.5 mm. Beobachten Sie, wie sich die Form des Histogramms verändert. Was\npassiert mit der Breite der Glocke?\n\nLösung\n\nBei scale=0.05 ist die Glocke sehr schmal und hoch: Fast alle Werte liegen\nnahe am Mittelwert 25.0 mm, was einem sehr präzisen Fertigungsprozess\nentspricht. Bei scale=0.5 ist die Glocke sehr breit und flach: Die Werte\nstreuen stark um den Mittelwert. Ein breiteres Histogramm bedeutet also mehr\nFertigungsstreuung und damit eine höhere Ausschussquote.\n\nAusblick\n\nIn diesem Kapitel füllen wir Listen mit einer for-Schleife. NumPy bietet\neine kompaktere Alternative: np.random.normal(loc=25.0, scale=0.15, size=1000)\nerzeugt 1000 Zufallszahlen in einer einzigen Zeile. Diese sogenannte\nVektorisierung ist einer der zentralen Vorteile von NumPy und wird im\nNumPy-Kapitel ausführlich behandelt.","type":"content","url":"/chapter06-sec02#verteilungen-sichtbar-machen-px-histogram","position":9},{"hierarchy":{"lvl1":"6.2 Zufallszahlen und Simulation","lvl2":"Zusammenfassung und Ausblick"},"type":"lvl2","url":"/chapter06-sec02#zusammenfassung-und-ausblick","position":10},{"hierarchy":{"lvl1":"6.2 Zufallszahlen und Simulation","lvl2":"Zusammenfassung und Ausblick"},"content":"In diesem Kapitel haben wir NumPy zum ersten Mal kennengelernt und mit\nnumpy.random erste Simulationen durchgeführt. Wir haben den Unterschied\nzwischen Gleichverteilung und Normalverteilung kennengelernt und mit\npx.histogram() sichtbar gemacht, warum die Normalverteilung für\nFertigungsprozesse das realistischere Modell ist. In einem späteren Kapitel\nwerden wir NumPy vollständig einführen, Histogramme vertiefen und die Simulation\num weitere statistische Kenngrößen ergänzen.","type":"content","url":"/chapter06-sec02#zusammenfassung-und-ausblick","position":11},{"hierarchy":{"lvl1":"Willkommen zu meinem Vorlesungsskript Python"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Willkommen zu meinem Vorlesungsskript Python"},"content":"TH Mannheim markdownlint-disable MD001 ","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Willkommen zu meinem Vorlesungsskript Python","lvl2":"Vorlesungsskript Python"},"type":"lvl2","url":"/#vorlesungsskript-python","position":2},{"hierarchy":{"lvl1":"Willkommen zu meinem Vorlesungsskript Python","lvl2":"Vorlesungsskript Python"},"content":" markdownlint-enable MD001 \n\nDie Digitalisierung in den Ingenieurwissenschaften nimmt zu. Daher bietet dieser\nPython-Kurs zukünftigen Ingenieurinnen und Ingenieuren einen Einstieg in die\ngrundlegenden Programmiertechniken mit Python. Jedes Kapitel entspricht dabei\neiner Vorlesung mit integrierten Übungen von 90 min Dauer. Weitere Übungen\ndienen der Vertiefung der gelernten Inhalte im Selbststudium.","type":"content","url":"/#vorlesungsskript-python","position":3},{"hierarchy":{"lvl1":"Inhaltsverzeichnis"},"type":"lvl1","url":"/toc","position":0},{"hierarchy":{"lvl1":"Inhaltsverzeichnis"},"content":"Python\n\nInhaltsverzeichnis\n\n1. Grundlagen und erste Schritte\n\n1.1 Algorithmus und Programmiersprachen\n\n1.2 Jupyter Notebooks und Python als Taschenrechner\n\nÜbungen\n\n2. Daten speichern und verwalten\n\n2.1 Datentypen und Variablen\n\n2.2 Benutzereingaben\n\nÜbungen\n\n3. Datensammlungen visualisieren\n\n3.1 Listen\n\n3.2 Liniendiagramme\n\nÜbungen\n\n4. Entscheidungen treffen\n\n4.1 Wahrheitswerte und Vergleiche\n\n4.2 Einfache Verzweigung\n\nÜbungen\n\n5. Wiederholungen automatisieren\n\n5.1 for-Schleifen\n\n5.2 Balkendiagramme\n\nÜbungen\n\n6. Formatierung und Simulation\n\n6.1 Indizierung, Strings und f-Strings\n\n6.2 Zufallszahlen und Simulation","type":"content","url":"/toc","position":1}]}